<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAG6ElEQVR4Ae3dbVqjOhQA4HgfF+Ks5Do78a7EupJxJ+NOZnbiJTpV7BAgtKSc9u0fKZDk8CaHj5ZKSl4ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQOB6BG5Cb+pj2qWb9Bh6Gy4h+Nf0X3pKzxE3JWYC7NJrROyLjznvjoK9/gkWb+r2+T/CxXwtAecdUz4qB3rFS4CUHgL5Xl+owU5JYyWAvX+MhNqlnzECTSlWAtj7RxlX91ECjZYAUVzFGURAAgTpKGGuIyAB1nFVaxABCRCko4S5joAEWMdVrUEEJECQjhLmOgISYB1XtQYRkABBOkqY6whIgHVc1RpEQAIE6ShhriMgAdZxVWsQAQkQpKOEuY6ABFjHVa1BBCRAkI4S5joCt+tU27DWgD/Da6jTrqmgP1N1BGg3RLS0QQEJsMFOEVI7AQnQzlpLGxSQABvsFCG1E5AA7ay1tEEBCbDBThFSOwEJ0M5aSxsUkAAb7BQhtROQAO2stbRBAQmwwU4RUjuB+LdCtLNat6X+rQRu71jXule7I0AP4yyTu/Sr+3/KX//d++H7swR2HY1KgPP38935Q7jeCCTA9fa9Le8EXAOcchj0T11e07fusUG/T1b9Y7rrnr/y66M+1wkfFMdMOAIco9cv2x/8eX5/sPbXWzL9/iy0z8Gf6zhsb0m9yoR7PsD2uiw/tGPpYCyVyw+d679KT13J5YM9kqi/WVuYdgQ4phce031X/OGYKgbL1jxxMSfHexyDVZk5LiABxn3KS/Pe96bRo4Be0/dyIN2SVnGMBhFzoQRY0m+lU5d+Xae8SH1KL91p1vgjSHNMc+Lqx2jaNUD1GJgeZNODNTdaOncfG+hjy/YbMh3ffk1/OwFHgJphMGdw7SZOV/btlS5s98tLf+clwY9ScfO/CkiArx7ld9OD/3nyNKVce92SnASv3bcM5deD06EyTn/Jbf+N6QGB6YGfTjjwnwciGJ711LW6S/92C++HV+jm5tjnHDGKFVz+AkeAY/t46hOaofpLD/zeHXz+P1S2Py+fbh1+Z9BfnqfnJPBhmSt6LwHGOntq8OS9a/6Epv71UF+kUCJ/ZzC1l5/ajkLV1zBbAizt5alBt7TepeXyvUde1QISoJrsT4F8H/+WXqe892hL27VyLLcr1x+7+rxXLQ+su7fz61Pf9VkrdniX6FD5rR2thmI80zxHgDH4fDvz1EVmOUGGay5fAI9/0ztUWz63n2rf4B+S+5gnAT4oChP5InPq/LruIvOh0NLpZxv8k6ZOgSaJuhXef9hy83bKU1p/nwQtBt2+rVIseX6LOMbaD7LMEaCmo+YMqjmDs6bNw3Xn1D8nzsN6r/S9BKjt+DmDqzRId8Xbp19mhVGqt194Tnz99a98WgIsGQBzBtnwYL0fbG7qBrr8g5fh+j6ryzHNieuzhKlOQAIsHQYtB9zUD14M/KW9KAEWy30WfP6cXDR1bPmXRa0q9CbgCHDsQMg3sE19TJrbKJ3CzLkBrnTr8/tR6Puxm3DN5SXAKXo/f0x6eBpy+P6Ydt5vff76Rdkp6z8mtuBlb4PHv63w1x6Ua9e/Lc0m0TgCNGHWyFYFJMA5e8Ye/Zz6b21LgFZd8Pdg/92qae2UBVwDlG1Ov+TvJDh9G2qsEnAEqOKy8qUJSIBL61HbUyUgAaq4rHxpAhLg0nrU9lQJSIAqLitfmoAEuLQetT1VAhKgisvKlyYgAS6tR21PlYAEqOKy8qBA+aeeg6tvaWasb4Lz/+i56R5K13/l++xL98v31zO9jsDQcw6m/pfSOpEsqvXrPeaLqmhcqPTDksZhaG5EINAtH/ESILtLgpHRd+ZFgQZ/lop6DfBy5m7W/JBAsMGfNyHmEWCP70iwlzj/34CD//xoIiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGgm8D9fZLEvqyRhqAAAAABJRU5ErkJggg==">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet">
    <script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>ToolKit</title>
    <style>
        * {
            font-family: "Rajdhani", sans-serif;
            font-weight: 500;
            font-style: normal;
        }
        body {
            margin: 0;
            background-color: #848484;
        }
        #customHTML {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            scrollbar-width: none;
        }
        #options {
            min-width: calc(100% - 10px);
            min-height: auto;
            border: solid black 5px;
            background-color: #151515;
            display: flex;
            flex-direction: column;
        }
        #output {
            width: 100%;
            min-height: auto;
        }
        @media (min-width: 800px) {
            #customHTML {
                flex-direction: row;
            }
            #options {
                height: calc(100% - 10px);
                min-width: 360px;
                overflow-y: auto;
                scrollbar-width: none;
            }
            #output {
                overflow-y: auto;
                scrollbar-width: none;
            }
        }
        @font-face {
            font-family: 'CustomFont';
            src: url(data:font/ttf;base64,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);
        }
    </style>
    <!-- Default Styling -->
</head>
<body>
    
    <div id="customHTML">
        <div id="options" style="display: flex;"></div>
        <div id="output" style="height: auto;"></div>
    </div>

    <script>
        const customHTML = document.getElementById("customHTML");
        const optionsArea = document.getElementById("options");
        const outputArea = document.getElementById("output");
        let editMode = false;
        let path = [];
        let db;
        
//MARK
let notes = {
    "Games": {
        "Mini Games": {
            "!Game Framework": "J:\n/*\n\ngameFramework({\n    width: 200,\n    height: 300,\n    spritesheet: [base64String, quantX, quantY],\n    sprites: [ listOfBase64Strings ],\n    audio: [ listOfBase64Strings ],\n    levels: [\n        {\n            init() {},\n            update(delta) {}\n        },\n        {\n            init() {},\n            update(delta) {}\n        }\n    ]\n});\n\nAvailableFunctions\ncls(colour)\nspr(id, x, y, w, h, r)    !! w & h are in pixels !!\nssh(id, x, y, w, h, r)    !! w & h are in pixels !!\nsfx(id, loop)\nclk(str/int/{x, y, w, h} , controllerID)\nhld(str/int/{x, y, w, h} , controllerID)\nlvl(id)\n\n*/\n\n\n\n\n\n\n",
            "!Map1": {},
            "Map Maker": "J:let mapObject = notes[\"Games\"][\"Mini Games\"][\"!Map1\"]\n\nconst spriteSheetBase64 = notes[\"Files\"][\"SS\"][\"!Data\"];\nif (!spriteSheetBase64) {\n    alert(\"Spritesheet data (notes['Files']['SS']['!Data']) not found!\");\n    showOption();\n    return;\n}\n\nconst SPRITE_SIZE = 16;\nconst GRID_CELL_SIZE = 16;\nconst NUM_LAYERS = 4;\nconst SPRITE_PALETTE_BG_COLOR = '#363737';\n\nlet sprites = [];\nlet spriteSheetImage = null;\nlet selectedSpriteId = 0;\nlet currentRotation = 0;\nlet currentLayer = 1;\n\nlet zoomLevel = 1;\nconst minZoom = 0.25;\nconst maxZoom = 32;\nlet panX = 0;\nlet panY = 0;\nlet isMouseLeftDown = false;\nlet isMouseMiddlePanning = false;\nlet isMouseLeftPanning = false;\nlet lastPointerX = 0;\nlet lastPointerY = 0;\nlet hoverGridX = null; // Use null to indicate no valid hover initially\nlet hoverGridY = null;\nlet isPanModeActive = false;\nlet isEraseModeActive = false;\n\nlet touchPoints = {};\nlet isPinching = false;\nlet initialPinchDistance = 0;\nlet pinchStartZoom = 1;\nlet touchActionIdentifier = null;\nlet isTouchPanning = false;\nlet potentialTap = false;\nconst tapThreshold = 10;\nlet isTouchDrawing = false;\nlet lastPinchMidpoint = null;\n\noptionsArea.innerHTML = \"\";\noutputArea.innerHTML = `\n    <div style=\"display: flex; flex-direction: column; align-items: center; padding: 10px; height: calc(100vh - 120px);\">\n        <div id=\"canvasContainer\" style=\"overflow: hidden; border: 1px solid black; margin-bottom: 10px; width: 90%; height: 85%; position: relative; background-color: #333333; touch-action: none;\">\n            <canvas id=\"displayCanvas\" style=\"position: absolute; top: 0; left: 0; image-rendering: pixelated; image-rendering: crisp-edges; cursor: crosshair; display: block;\"></canvas>\n        </div>\n        <div style=\"display: flex; justify-content: center; align-items: flex-start; margin-bottom: 5px; flex-wrap: wrap; width: 90%;\">\n            <div id=\"spritePaletteContainer\" style=\"line-height: 0; margin-right: 15px; border: 1px solid #ccc; padding: 2px; max-height: 150px; overflow-y: auto; background-color: ${SPRITE_PALETTE_BG_COLOR};\">\n                Loading Sprites...\n            </div>\n            <div style=\"display: flex; flex-direction: column; gap: 5px;\">\n                <button id=\"panModeButton\" style=\"padding: 5px 10px; border: 1px solid #888; border-radius: 4px; background-color: #f0f0f0; cursor: pointer;\">Pan: OFF</button>\n                <button id=\"eraseModeButton\" style=\"padding: 5px 10px; border: 1px solid #888; border-radius: 4px; background-color: #f0f0f0; cursor: pointer;\">Erase: OFF</button>\n                <button id=\"rotateButton\" style=\"padding: 5px 10px; border: 1px solid #888; border-radius: 4px; background-color: #f0f0f0; cursor: pointer;\">Rotate: 0°</button>\n                <div id=\"layerSelector\" style=\"display: flex; gap: 3px;\">\n                </div>\n            </div>\n        </div>\n        <div id=\"editorInfo\" style=\"font-size: 0.8em; color: #ccc; min-height: 1.2em; text-align: center; width: 90%;\"></div>\n    </div>\n`;\n\nconst canvasContainer = document.getElementById('canvasContainer');\nconst displayCanvas = document.getElementById('displayCanvas');\nconst displayCtx = displayCanvas.getContext('2d');\ndisplayCtx.imageSmoothingEnabled = false;\nconst spritePaletteContainer = document.getElementById('spritePaletteContainer');\nconst editorInfo = document.getElementById('editorInfo');\nconst panModeButton = document.getElementById('panModeButton');\nconst eraseModeButton = document.getElementById('eraseModeButton');\nconst rotateButton = document.getElementById('rotateButton');\nconst layerSelector = document.getElementById('layerSelector');\n\nfunction loadAndSliceSpriteSheet(base64Data, spriteWidth, spriteHeight) {\n    return new Promise((resolve, reject) => {\n        spriteSheetImage = new Image();\n        spriteSheetImage.onload = () => {\n            const sheetWidth = spriteSheetImage.naturalWidth;\n            const sheetHeight = spriteSheetImage.naturalHeight;\n            const cols = Math.floor(sheetWidth / spriteWidth);\n            const rows = Math.floor(sheetHeight / spriteHeight);\n            const loadedSprites = [];\n            let spriteId = 0;\n\n            for (let y = 0; y < rows; y++) {\n                for (let x = 0; x < cols; x++) {\n                    const canvas = document.createElement('canvas');\n                    canvas.width = spriteWidth;\n                    canvas.height = spriteHeight;\n                    const ctx = canvas.getContext('2d');\n                    ctx.imageSmoothingEnabled = false;\n                    ctx.drawImage(\n                        spriteSheetImage,\n                        x * spriteWidth, y * spriteHeight,\n                        spriteWidth, spriteHeight,\n                        0, 0,\n                        spriteWidth, spriteHeight\n                    );\n                    loadedSprites.push({ id: spriteId++, canvas: canvas });\n                }\n            }\n            resolve(loadedSprites);\n        };\n        spriteSheetImage.onerror = (err) => {\n            reject(`Error loading spritesheet image: ${err}`);\n        };\n        spriteSheetImage.src = base64Data;\n    });\n}\n\nfunction buildSpritePaletteUI() {\n    spritePaletteContainer.innerHTML = '';\n    sprites.forEach(spriteData => {\n        const swatch = spriteData.canvas.cloneNode();\n        const swatchCtx = swatch.getContext('2d');\n        swatchCtx.drawImage(spriteData.canvas, 0, 0);\n        swatch.style.width = `${SPRITE_SIZE * 2}px`;\n        swatch.style.height = `${SPRITE_SIZE * 2}px`;\n        swatch.style.border = '1px solid #ccc';\n        swatch.style.display = 'inline-block';\n        swatch.style.margin = '1px';\n        swatch.style.cursor = 'pointer';\n        swatch.style.imageRendering = 'pixelated';\n        if (spriteData.id === selectedSpriteId) {\n            swatch.style.border = '2px solid blue';\n            swatch.style.backgroundColor = '#aaf';\n        }\n        swatch.addEventListener('click', () => {\n            isEraseModeActive = false;\n            eraseModeButton.textContent = `Erase: OFF`;\n            eraseModeButton.style.backgroundColor = '#f0f0f0';\n\n            selectedSpriteId = spriteData.id;\n            Array.from(spritePaletteContainer.children).forEach((child, index) => {\n                 const childSpriteId = sprites[index]?.id;\n                 if (childSpriteId === selectedSpriteId) {\n                     child.style.border = '2px solid blue';\n                     child.style.backgroundColor = '#aaf';\n                 } else {\n                     child.style.border = '1px solid #ccc';\n                      child.style.backgroundColor = 'transparent';\n                 }\n            });\n            if (!isPanModeActive) {\n                displayCanvas.style.cursor = 'crosshair';\n            }\n             redrawDisplayCanvas();\n        });\n        spritePaletteContainer.appendChild(swatch);\n    });\n}\n\n function buildLayerSelectorUI() {\n    layerSelector.innerHTML = '';\n    for (let i = 1; i <= NUM_LAYERS; i++) {\n        const btn = document.createElement('button');\n        btn.textContent = `L${i}`;\n        btn.style.padding = '3px 6px';\n        btn.style.fontSize = '0.9em';\n        btn.style.border = '1px solid #888';\n        btn.style.borderRadius = '3px';\n        btn.style.cursor = 'pointer';\n        if (i === currentLayer) {\n            btn.style.backgroundColor = '#a0d0ff';\n            btn.style.fontWeight = 'bold';\n        } else {\n            btn.style.backgroundColor = '#f0f0f0';\n            btn.style.fontWeight = 'normal';\n        }\n        btn.addEventListener('click', () => {\n            currentLayer = i;\n            buildLayerSelectorUI();\n            redrawDisplayCanvas();\n        });\n        layerSelector.appendChild(btn);\n    }\n}\n\npanModeButton.addEventListener('click', () => {\n    isPanModeActive = !isPanModeActive;\n    panModeButton.textContent = `Pan: ${isPanModeActive ? 'ON' : 'OFF'}`;\n    panModeButton.style.backgroundColor = isPanModeActive ? '#a0d0a0' : '#f0f0f0';\n    if (isPanModeActive) {\n        displayCanvas.style.cursor = 'grab';\n    } else {\n        displayCanvas.style.cursor = isEraseModeActive ? 'cell' : 'crosshair';\n    }\n    isMouseLeftDown = false; isTouchDrawing = false; isMouseLeftPanning = false; isTouchPanning = false;\n});\n\neraseModeButton.addEventListener('click', () => {\n    isEraseModeActive = !isEraseModeActive;\n    eraseModeButton.textContent = `Erase: ${isEraseModeActive ? 'ON' : 'OFF'}`;\n    eraseModeButton.style.backgroundColor = isEraseModeActive ? '#ffaaaa' : '#f0f0f0';\n    if (isEraseModeActive) {\n        Array.from(spritePaletteContainer.children).forEach(child => {\n            child.style.border = '1px solid #ccc';\n            child.style.backgroundColor = 'transparent';\n        });\n    } else if (selectedSpriteId !== null) {\n       const swatchIndex = sprites.findIndex(s => s.id === selectedSpriteId);\n       if (swatchIndex !== -1) {\n           const swatch = spritePaletteContainer.children[swatchIndex];\n           if(swatch){\n               swatch.style.border = '2px solid blue';\n               swatch.style.backgroundColor = '#aaf';\n           }\n       }\n    }\n\n    if (!isPanModeActive) {\n        displayCanvas.style.cursor = isEraseModeActive ? 'cell' : 'crosshair';\n    }\n     redrawDisplayCanvas();\n});\n\nrotateButton.addEventListener('click', () => {\n    currentRotation = (currentRotation + 90) % 360;\n    rotateButton.textContent = `Rotate: ${currentRotation}°`;\n     redrawDisplayCanvas();\n});\n\nfunction resizeAndRedraw() {\n    displayCanvas.width = canvasContainer.clientWidth;\n    displayCanvas.height = canvasContainer.clientHeight;\n    displayCtx.imageSmoothingEnabled = false;\n    redrawDisplayCanvas();\n}\n\nfunction redrawDisplayCanvas() {\n    if (!spriteSheetImage || sprites.length === 0) return;\n\n    const viewWidth = displayCanvas.width;\n    const viewHeight = displayCanvas.height;\n\n    displayCtx.imageSmoothingEnabled = false;\n    displayCtx.fillStyle = '#333333';\n    displayCtx.fillRect(0, 0, viewWidth, viewHeight);\n\n    displayCtx.save();\n    displayCtx.translate(viewWidth / 2, viewHeight / 2);\n    displayCtx.scale(zoomLevel, zoomLevel);\n    displayCtx.translate(-panX, -panY);\n    // Removed initial centering translation\n\n    const viewLeft = ((-viewWidth / 2) / zoomLevel) + panX;\n    const viewTop = ((-viewHeight / 2) / zoomLevel) + panY;\n    const viewRight = viewLeft + viewWidth / zoomLevel;\n    const viewBottom = viewTop + viewHeight / zoomLevel;\n\n    const startCol = Math.floor(viewLeft / GRID_CELL_SIZE);\n    const endCol = Math.ceil(viewRight / GRID_CELL_SIZE);\n    const startRow = Math.floor(viewTop / GRID_CELL_SIZE);\n    const endRow = Math.ceil(viewBottom / GRID_CELL_SIZE);\n\n\n    for (let layer = 1; layer <= NUM_LAYERS; layer++) {\n        for (let gy = startRow; gy < endRow; gy++) {\n            for (let gx = startCol; gx < endCol; gx++) {\n                const key = `${gx}x${gy}`;\n                if (mapObject[key] && mapObject[key][layer - 1] && mapObject[key][layer - 1].length === 2) {\n                    const [spriteId, rotation] = mapObject[key][layer - 1];\n                    const spriteData = sprites.find(s => s.id === spriteId);\n\n                    if (spriteData) {\n                        const drawX = gx * GRID_CELL_SIZE;\n                        const drawY = gy * GRID_CELL_SIZE;\n\n                        displayCtx.save();\n\n                        if (layer !== currentLayer) {\n                            displayCtx.globalAlpha = 0.35;\n                        } else {\n                            displayCtx.globalAlpha = 1.0;\n                        }\n\n                        const centerX = drawX + GRID_CELL_SIZE / 2;\n                        const centerY = drawY + GRID_CELL_SIZE / 2;\n                        displayCtx.translate(centerX, centerY);\n                        displayCtx.rotate(rotation * Math.PI / 180);\n                        displayCtx.translate(-centerX, -centerY);\n\n                        displayCtx.drawImage(spriteData.canvas, drawX, drawY, GRID_CELL_SIZE, GRID_CELL_SIZE);\n\n                        displayCtx.restore();\n                    }\n                }\n            }\n        }\n    }\n\n    displayCtx.globalAlpha = 1.0;\n\n\n    if (zoomLevel * GRID_CELL_SIZE > 4) {\n        displayCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n        displayCtx.lineWidth = 1 / zoomLevel;\n\n        for (let gx = startCol; gx <= endCol; gx++) {\n            displayCtx.beginPath();\n            displayCtx.moveTo(gx * GRID_CELL_SIZE, startRow * GRID_CELL_SIZE);\n            displayCtx.lineTo(gx * GRID_CELL_SIZE, endRow * GRID_CELL_SIZE);\n            displayCtx.stroke();\n        }\n        for (let gy = startRow; gy <= endRow; gy++) {\n             displayCtx.beginPath();\n             displayCtx.moveTo(startCol * GRID_CELL_SIZE, gy * GRID_CELL_SIZE);\n             displayCtx.lineTo(endCol * GRID_CELL_SIZE, gy * GRID_CELL_SIZE);\n            displayCtx.stroke();\n        }\n    }\n\n    // Removed Map Border drawing\n\n    const showHover = hoverGridX !== null && hoverGridY !== null && !isPinching && Object.keys(touchPoints).length <= 1 && !isMouseMiddlePanning && !isMouseLeftPanning && !isTouchPanning && !isTouchDrawing && !isMouseLeftDown;\n\n    if (showHover) {\n        const hx = hoverGridX * GRID_CELL_SIZE;\n        const hy = hoverGridY * GRID_CELL_SIZE;\n\n         if (isEraseModeActive) {\n             displayCtx.strokeStyle = \"rgba(255, 0, 0, 0.8)\";\n             displayCtx.lineWidth = 2 / zoomLevel;\n              displayCtx.strokeRect(hx + 1 / zoomLevel, hy + 1 / zoomLevel, GRID_CELL_SIZE - 2 / zoomLevel, GRID_CELL_SIZE - 2 / zoomLevel);\n             displayCtx.beginPath();\n             displayCtx.moveTo(hx + 2 / zoomLevel, hy + 2 / zoomLevel);\n             displayCtx.lineTo(hx + GRID_CELL_SIZE - 2 / zoomLevel, hy + GRID_CELL_SIZE - 2 / zoomLevel);\n             displayCtx.moveTo(hx + GRID_CELL_SIZE - 2 / zoomLevel, hy + 2 / zoomLevel);\n             displayCtx.lineTo(hx + 2 / zoomLevel, hy + GRID_CELL_SIZE - 2 / zoomLevel);\n             displayCtx.stroke();\n         } else if (selectedSpriteId !== null) {\n             const spriteData = sprites.find(s => s.id === selectedSpriteId);\n             if (spriteData) {\n                 displayCtx.save();\n                 displayCtx.globalAlpha = 0.7;\n\n                 const centerX = hx + GRID_CELL_SIZE / 2;\n                 const centerY = hy + GRID_CELL_SIZE / 2;\n                 displayCtx.translate(centerX, centerY);\n                 displayCtx.rotate(currentRotation * Math.PI / 180);\n                 displayCtx.translate(-centerX, -centerY);\n\n                 displayCtx.drawImage(spriteData.canvas, hx, hy, GRID_CELL_SIZE, GRID_CELL_SIZE);\n                 displayCtx.restore();\n\n                 displayCtx.strokeStyle = \"rgba(255, 255, 0, 0.9)\";\n                 displayCtx.lineWidth = 1.5 / zoomLevel;\n                 displayCtx.strokeRect(hx, hy, GRID_CELL_SIZE, GRID_CELL_SIZE);\n             }\n         }\n    }\n\n    displayCtx.restore();\n\n    const hoverCoordsText = (hoverGridX !== null && hoverGridY !== null) ? `(${hoverGridX}, ${hoverGridY})` : '(N/A)';\n    editorInfo.textContent = `Layer: ${currentLayer} | Zoom: ${zoomLevel.toFixed(2)}x | View: (${Math.round(panX)}, ${Math.round(panY)}) | Hover: ${hoverCoordsText} | Sel: ${selectedSpriteId !== null ? selectedSpriteId : 'None'}@${currentRotation}° ${isEraseModeActive ? '(Erase)' : ''}`;\n}\n\nfunction getGridCoords(clientX, clientY) {\n    const rect = displayCanvas.getBoundingClientRect();\n    const canvasX = clientX - rect.left;\n    const canvasY = clientY - rect.top;\n\n    const worldX = ((canvasX - displayCanvas.width / 2) / zoomLevel) + panX;\n    const worldY = ((canvasY - displayCanvas.height / 2) / zoomLevel) + panY;\n\n    const gridX = Math.floor(worldX / GRID_CELL_SIZE);\n    const gridY = Math.floor(worldY / GRID_CELL_SIZE);\n\n    // Return coords directly, no bounds check for infinite map\n    return { x: gridX, y: gridY };\n}\n\nfunction placeOrEraseSprite(gridX, gridY) {\n    // No need to check gridX/gridY against -1 as getGridCoords no longer returns it for out of bounds\n    if (gridX === null || gridY === null) return; // Should not happen if called correctly, but safety check\n\n    const key = `${gridX}x${gridY}`;\n\n    if (!mapObject[key]) {\n        mapObject[key] = [];\n        for(let i = 0; i < NUM_LAYERS; i++) mapObject[key].push([]);\n    } else if (!Array.isArray(mapObject[key])){\n        console.warn(`Invalid data format for key ${key}, resetting.`);\n        mapObject[key] = [];\n        for(let i = 0; i < NUM_LAYERS; i++) mapObject[key].push([]);\n    } else {\n        while(mapObject[key].length < NUM_LAYERS) {\n            mapObject[key].push([]);\n        }\n    }\n\n    const currentCellData = mapObject[key][currentLayer - 1];\n    let needsRedraw = false;\n\n    if (isEraseModeActive) {\n         if (currentCellData && currentCellData.length > 0) {\n             mapObject[key][currentLayer - 1] = [];\n             needsRedraw = true;\n        }\n    } else if (selectedSpriteId !== null) {\n        const newData = [selectedSpriteId, currentRotation];\n         if (!currentCellData || currentCellData.length === 0 || currentCellData[0] !== newData[0] || currentCellData[1] !== newData[1]) {\n              mapObject[key][currentLayer - 1] = newData;\n              needsRedraw = true;\n         }\n    }\n\n    // Optional cleanup - remove fully empty keys\n    // if (mapObject[key].every(layerData => !layerData || layerData.length === 0)) {\n    //     delete mapObject[key];\n    //     // Deleting might cause issues if you expect keys to persist?\n    //     // Keep this commented unless sure it's desired behavior.\n    // }\n\n    if (needsRedraw) {\n         redrawDisplayCanvas();\n    }\n}\n\nfunction getDistance(p1, p2) {\n    const dx = p1.clientX - p2.clientX;\n    const dy = p1.clientY - p2.clientY;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction getMidpoint(p1, p2) {\n    return {\n        clientX: (p1.clientX + p2.clientX) / 2,\n        clientY: (p1.clientY + p2.clientY) / 2,\n    };\n}\n\nfunction handlePointerDown(identifier, clientX, clientY, isPrimary, eventSource) {\n    touchPoints[identifier] = { clientX, clientY, startX: clientX, startY: clientY, startTime: performance.now() };\n    const touchCount = Object.keys(touchPoints).length;\n\n    if (touchCount === 1 && isPrimary) {\n        touchActionIdentifier = identifier;\n        lastPointerX = clientX;\n        lastPointerY = clientY;\n        isTouchPanning = false;\n        isMouseLeftPanning = false;\n        isTouchDrawing = false;\n        potentialTap = true;\n\n        if (isPanModeActive) {\n             if (eventSource === 'touch') { isTouchPanning = true; }\n             if (eventSource === 'mouse') { isMouseLeftPanning = true; }\n             displayCanvas.style.cursor = 'grabbing';\n        } else {\n             const coords = getGridCoords(clientX, clientY);\n            // Check if coords are valid numbers before placing\n            if (coords.x !== null && coords.y !== null) {\n                if (eventSource === 'mouse') {\n                     isMouseLeftDown = true;\n                     placeOrEraseSprite(coords.x, coords.y);\n                } else if (eventSource === 'touch') {\n                     isTouchDrawing = true;\n                     // Don't place on touch down for drawing, wait for move/up\n                }\n            }\n             displayCanvas.style.cursor = isEraseModeActive ? 'cell' : 'crosshair';\n        }\n         if (hoverGridX !== null || hoverGridY !== null) {\n              hoverGridX = null; hoverGridY = null;\n         }\n\n    } else if (touchCount === 2) {\n        isMouseLeftDown = false; isTouchDrawing = false;\n        isTouchPanning = false; isMouseLeftPanning = false;\n        isPinching = true;\n        potentialTap = false;\n        const touches = Object.values(touchPoints);\n        initialPinchDistance = getDistance(touches[0], touches[1]);\n        pinchStartZoom = zoomLevel;\n        lastPinchMidpoint = getMidpoint(touches[0], touches[1]);\n        displayCanvas.style.cursor = 'move';\n        hoverGridX = null; hoverGridY = null;\n        redrawDisplayCanvas();\n    }\n    if(!isPanModeActive && (isMouseLeftDown || isTouchDrawing)){\n         redrawDisplayCanvas();\n    }\n}\n\nfunction handlePointerMove(identifier, clientX, clientY) {\n    if (identifier === 'mouse' && !isMouseLeftDown && !isMouseMiddlePanning && !isMouseLeftPanning && Object.keys(touchPoints).length === 0 && !isPinching && !isTouchDrawing && !isTouchPanning) {\n        const coords = getGridCoords(clientX, clientY);\n        let needsRedraw = false;\n        // Only update if coords are valid numbers\n        if (coords.x !== null && coords.y !== null && (coords.x !== hoverGridX || coords.y !== hoverGridY)) {\n             hoverGridX = coords.x; hoverGridY = coords.y; needsRedraw = true;\n        } else if ((coords.x === null || coords.y === null) && (hoverGridX !== null || hoverGridY !== null)) {\n            // Moved off valid grid area\n            hoverGridX = null; hoverGridY = null; needsRedraw = true;\n        }\n        if (needsRedraw) redrawDisplayCanvas();\n        return;\n    }\n\n    if (!touchPoints[identifier]) return;\n\n    const currentPointer = touchPoints[identifier];\n    const startInfo = touchPoints[identifier];\n    currentPointer.clientX = clientX;\n    currentPointer.clientY = clientY;\n\n    const touchCount = Object.keys(touchPoints).length;\n\n    if (isPinching && touchCount === 2) {\n        potentialTap = false;\n        const touches = Object.values(touchPoints);\n        const currentDistance = getDistance(touches[0], touches[1]);\n        const currentMidpoint = getMidpoint(touches[0], touches[1]);\n\n        if (initialPinchDistance > 0 && lastPinchMidpoint) {\n             const zoomRatio = currentDistance / initialPinchDistance;\n             const newZoomLevelTarget = pinchStartZoom * zoomRatio;\n             const newZoomLevel = Math.max(minZoom, Math.min(maxZoom, newZoomLevelTarget));\n\n             const rect = displayCanvas.getBoundingClientRect();\n             const canvasMidX = currentMidpoint.clientX - rect.left;\n             const canvasMidY = currentMidpoint.clientY - rect.top;\n\n             const worldXUnderMidpoint = ((canvasMidX - displayCanvas.width / 2) / zoomLevel) + panX;\n             const worldYUnderMidpoint = ((canvasMidY - displayCanvas.height / 2) / zoomLevel) + panY;\n\n             let zoomCorrectedPanX = worldXUnderMidpoint - ((canvasMidX - displayCanvas.width / 2) / newZoomLevel);\n             let zoomCorrectedPanY = worldYUnderMidpoint - ((canvasMidY - displayCanvas.height / 2) / newZoomLevel);\n\n\n             const deltaMidX = currentMidpoint.clientX - lastPinchMidpoint.clientX;\n             const deltaMidY = currentMidpoint.clientY - lastPinchMidpoint.clientY;\n\n             let finalPanX = zoomCorrectedPanX - (deltaMidX / newZoomLevel);\n             let finalPanY = zoomCorrectedPanY - (deltaMidY / newZoomLevel);\n\n\n             if (Math.abs(newZoomLevel - zoomLevel) > 0.001 || Math.abs(finalPanX - panX) > 0.1 || Math.abs(finalPanY - panY) > 0.1) {\n                 zoomLevel = newZoomLevel;\n                 panX = finalPanX;\n                 panY = finalPanY;\n                 redrawDisplayCanvas();\n             }\n        }\n        lastPinchMidpoint = currentMidpoint;\n\n    }\n    else if (identifier === touchActionIdentifier && !isPinching) {\n        const dxPanDelta = clientX - lastPointerX;\n        const dyPanDelta = clientY - lastPointerY;\n\n        if (potentialTap) {\n             const dxMoveTotal = clientX - startInfo.startX;\n             const dyMoveTotal = clientY - startInfo.startY;\n             const distanceMoved = Math.sqrt(dxMoveTotal * dxMoveTotal + dyMoveTotal * dyMoveTotal);\n             if (distanceMoved > tapThreshold) {\n                 potentialTap = false;\n                 if (isPanModeActive && !isTouchPanning && !isMouseLeftPanning) {\n                     if (identifier === 'mouse') isMouseLeftPanning = true;\n                     else isTouchPanning = true;\n                     displayCanvas.style.cursor = 'grabbing';\n                 }\n                 if (!isPanModeActive && !isTouchDrawing && !isMouseLeftDown) {\n                     if (identifier === 'mouse') isMouseLeftDown = true;\n                     else isTouchDrawing = true;\n                      displayCanvas.style.cursor = isEraseModeActive ? 'cell' : 'crosshair';\n                 }\n             }\n        }\n\n         if ((isTouchPanning || isMouseLeftPanning) && isPanModeActive) {\n              potentialTap = false;\n              panX -= dxPanDelta / zoomLevel;\n              panY -= dyPanDelta / zoomLevel;\n              if (displayCanvas.style.cursor !== 'grabbing') { displayCanvas.style.cursor = 'grabbing';}\n              redrawDisplayCanvas();\n         }\n         else if (isMouseLeftDown && !isPanModeActive) {\n              potentialTap = false;\n              const coords = getGridCoords(clientX, clientY);\n              placeOrEraseSprite(coords.x, coords.y);\n         }\n         else if (isTouchDrawing && !isPanModeActive && !potentialTap) {\n              const coords = getGridCoords(clientX, clientY);\n              placeOrEraseSprite(coords.x, coords.y);\n          }\n\n        lastPointerX = clientX;\n        lastPointerY = clientY;\n    }\n}\n\nfunction handlePointerUp(identifier, clientX, clientY) {\n    const startInfo = touchPoints[identifier];\n    const touchCountBeforeEnd = Object.keys(touchPoints).length;\n\n    delete touchPoints[identifier];\n    const touchCountAfterEnd = Object.keys(touchPoints).length;\n\n    let cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair');\n\n    if (isPinching && touchCountBeforeEnd === 2 && touchCountAfterEnd < 2) {\n        isPinching = false;\n        initialPinchDistance = 0;\n        lastPinchMidpoint = null;\n         if (touchCountAfterEnd === 1) {\n             const remainingTouchId = Object.keys(touchPoints)[0];\n             const remainingTouch = touchPoints[remainingTouchId];\n             touchActionIdentifier = remainingTouchId;\n             lastPointerX = remainingTouch.clientX;\n             lastPointerY = remainingTouch.clientY;\n              isTouchPanning = false; isTouchDrawing = false; potentialTap = false;\n\n              if (isPanModeActive) {\n                   isTouchPanning = true;\n                   cursor = 'grabbing';\n              } else {\n                   isTouchDrawing = false;\n                   cursor = isEraseModeActive ? 'cell' : 'crosshair';\n              }\n             remainingTouch.startX = remainingTouch.clientX;\n             remainingTouch.startY = remainingTouch.clientY;\n             remainingTouch.startTime = performance.now();\n             potentialTap = true;\n\n         } else {\n              touchActionIdentifier = null;\n         }\n    }\n    else if (identifier === touchActionIdentifier) {\n\n         if (!isPanModeActive && potentialTap && startInfo) {\n              const dxMoveTotal = clientX - startInfo.startX;\n              const dyMoveTotal = clientY - startInfo.startY;\n              const distanceMoved = Math.sqrt(dxMoveTotal * dxMoveTotal + dyMoveTotal * dyMoveTotal);\n\n              if (distanceMoved <= tapThreshold) {\n                   const coords = getGridCoords(clientX, clientY);\n                   placeOrEraseSprite(coords.x, coords.y);\n              }\n         }\n\n        isTouchPanning = false;\n        isMouseLeftDown = false;\n        isMouseLeftPanning = false;\n        isTouchDrawing = false;\n        potentialTap = false;\n        touchActionIdentifier = null;\n    }\n\n    if (touchCountAfterEnd === 0) {\n        isTouchPanning = false; isMouseLeftDown = false; isMouseLeftPanning = false;\n        isTouchDrawing = false; isPinching = false; potentialTap = false;\n        touchActionIdentifier = null; lastPinchMidpoint = null;\n         cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair');\n    }\n\n    displayCanvas.style.cursor = cursor;\n    redrawDisplayCanvas();\n}\n\n\ndisplayCanvas.addEventListener('mousedown', (e) => {\n    if (e.button === 0) {\n        handlePointerDown('mouse', e.clientX, e.clientY, true, 'mouse');\n    } else if (e.button === 1) {\n        isMouseMiddlePanning = true;\n        lastPointerX = e.clientX;\n        lastPointerY = e.clientY;\n        displayCanvas.style.cursor = 'grabbing';\n        e.preventDefault();\n    }\n});\n\ndisplayCanvas.addEventListener('mousemove', (e) => {\n    if (isMouseMiddlePanning && (e.buttons & 4)) {\n        const dx = e.clientX - lastPointerX;\n        const dy = e.clientY - lastPointerY;\n        panX -= dx / zoomLevel;\n        panY -= dy / zoomLevel;\n        lastPointerX = e.clientX;\n        lastPointerY = e.clientY;\n        redrawDisplayCanvas();\n    } else if (isMouseMiddlePanning && !(e.buttons & 4)) {\n        isMouseMiddlePanning = false;\n        displayCanvas.style.cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair');\n        handlePointerMove('mouse', e.clientX, e.clientY);\n    }\n    else {\n        handlePointerMove('mouse', e.clientX, e.clientY);\n    }\n});\n\ndisplayCanvas.addEventListener('mouseup', (e) => {\n    if (e.button === 0) {\n        handlePointerUp('mouse', e.clientX, e.clientY);\n    } else if (e.button === 1) {\n        isMouseMiddlePanning = false;\n        displayCanvas.style.cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair');\n        const coords = getGridCoords(e.clientX, e.clientY);\n        hoverGridX = coords.x; hoverGridY = coords.y;\n        redrawDisplayCanvas();\n    }\n});\n\ndisplayCanvas.addEventListener('mouseleave', (e) => {\n    if (touchPoints['mouse']) {\n        handlePointerUp('mouse', e.clientX, e.clientY);\n    }\n    if (isMouseMiddlePanning) {\n        isMouseMiddlePanning = false;\n        displayCanvas.style.cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair');\n    }\n    if (hoverGridX !== null || hoverGridY !== null) {\n        hoverGridX = null; hoverGridY = null;\n        redrawDisplayCanvas();\n    }\n});\n\ndisplayCanvas.addEventListener('wheel', (e) => {\n    e.preventDefault();\n    const rect = displayCanvas.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const mouseY = e.clientY - rect.top;\n\n    const worldXBefore = ((mouseX - displayCanvas.width / 2) / zoomLevel) + panX;\n    const worldYBefore = ((mouseY - displayCanvas.height / 2) / zoomLevel) + panY;\n\n    const zoomFactor = 1.2;\n    let newZoomLevel;\n    if (e.deltaY < 0) {\n        newZoomLevel = Math.min(maxZoom, zoomLevel * zoomFactor);\n    } else {\n        newZoomLevel = Math.max(minZoom, zoomLevel / zoomFactor);\n    }\n\n    if(Math.abs(newZoomLevel - zoomLevel) < 0.001) return;\n\n     panX = worldXBefore - ((mouseX - displayCanvas.width / 2) / newZoomLevel);\n     panY = worldYBefore - ((mouseY - displayCanvas.height / 2) / newZoomLevel);\n\n    zoomLevel = newZoomLevel;\n\n    const coords = getGridCoords(e.clientX, e.clientY);\n    hoverGridX = coords.x; hoverGridY = coords.y;\n\n    redrawDisplayCanvas();\n});\n\ndisplayCanvas.addEventListener('touchstart', (e) => {\n    e.preventDefault();\n    for (let i = 0; i < e.changedTouches.length; i++) {\n        const touch = e.changedTouches[i];\n        const isPrimary = Object.keys(touchPoints).length === 0 && i === 0;\n        handlePointerDown(touch.identifier, touch.clientX, touch.clientY, isPrimary, 'touch');\n    }\n}, { passive: false });\n\ndisplayCanvas.addEventListener('touchmove', (e) => {\n    e.preventDefault();\n    for (let i = 0; i < e.changedTouches.length; i++) {\n        const touch = e.changedTouches[i];\n        if (touchPoints[touch.identifier]) {\n            handlePointerMove(touch.identifier, touch.clientX, touch.clientY);\n        }\n    }\n}, { passive: false });\n\ndisplayCanvas.addEventListener('touchend', (e) => {\n    e.preventDefault();\n    for (let i = 0; i < e.changedTouches.length; i++) {\n        const touch = e.changedTouches[i];\n        if (touchPoints[touch.identifier]) {\n            handlePointerUp(touch.identifier, touch.clientX, touch.clientY);\n        }\n    }\n}, { passive: false });\n\ndisplayCanvas.addEventListener('touchcancel', (e) => {\n    e.preventDefault();\n    for (let i = 0; i < e.changedTouches.length; i++) {\n        const touch = e.changedTouches[i];\n        if (touchPoints[touch.identifier]) {\n            handlePointerUp(touch.identifier, touch.clientX, touch.clientY);\n        }\n    }\n}, { passive: false });\n\nconst saveMap = () => {\n    try {\n        // Optional: Clean up empty keys before saving\n        Object.keys(mapObject).forEach(key => {\n             if (Array.isArray(mapObject[key]) && mapObject[key].every(layerData => !layerData || layerData.length === 0)) {\n                 delete mapObject[key];\n            }\n        });\n        saveData();\n        showOption();\n        alert(\"Map saved successfully!\");\n    } catch (error) {\n        console.error(\"Error saving map:\", error);\n        alert(\"Error saving map.\");\n    }\n};\nnewOptionButton(\"Save Map\", \"#393939\", saveMap);\n\nloadAndSliceSpriteSheet(spriteSheetBase64, SPRITE_SIZE, SPRITE_SIZE)\n    .then(loadedSprites => {\n        sprites = loadedSprites;\n        buildSpritePaletteUI();\n        buildLayerSelectorUI();\n        resizeAndRedraw();\n        window.addEventListener('resize', resizeAndRedraw);\n    })\n    .catch(error => {\n        console.error(error);\n        outputArea.innerHTML = `<p style=\"color: red;\">${error}</p>`;\n        alert(\"Could not load the spritesheet for editing.\");\n    });",
            "Chess": "J:window.aiDepth = 1;\nwindow.playerMode = \"PvP\";\nwindow.playerSide = \"W\";\nconst Q_SEARCH_MAX_DEPTH = 5;\n\nconst piecePSTs = {\n    'P': [\n        [  0,  0,  0,  0,  0,  0,  0,  0],\n        [ 50, 50, 50, 50, 50, 50, 50, 50],\n        [ 10, 10, 20, 30, 30, 20, 10, 10],\n        [  5,  5, 10, 25, 25, 10,  5,  5],\n        [  0,  0,  0, 20, 20,  0,  0,  0],\n        [  5, -5,-10,  0,  0,-10, -5,  5],\n        [  5, 10, 10,-20,-20, 10, 10,  5],\n        [  0,  0,  0,  0,  0,  0,  0,  0]\n    ],\n    'N': [\n        [-50,-40,-30,-30,-30,-30,-40,-50],\n        [-40,-20,  0,  0,  0,  0,-20,-40],\n        [-30,  0, 10, 15, 15, 10,  0,-30],\n        [-30,  5, 15, 20, 20, 15,  5,-30],\n        [-30,  0, 15, 20, 20, 15,  0,-30],\n        [-30,  5, 10, 15, 15, 10,  5,-30],\n        [-40,-20,  0,  5,  5,  0,-20,-40],\n        [-50,-40,-30,-30,-30,-30,-40,-50]\n    ],\n    'B': [\n        [-20,-10,-10,-10,-10,-10,-10,-20],\n        [-10,  0,  0,  0,  0,  0,  0,-10],\n        [-10,  0,  5, 10, 10,  5,  0,-10],\n        [-10,  5,  5, 10, 10,  5,  5,-10],\n        [-10,  0, 10, 10, 10, 10,  0,-10],\n        [-10, 10, 10, 10, 10, 10, 10,-10],\n        [-10,  5,  0,  0,  0,  0,  5,-10],\n        [-20,-10,-10,-10,-10,-10,-10,-20]\n    ],\n    'R': [\n        [  0,  0,  0,  0,  0,  0,  0,  0],\n        [  5, 10, 10, 10, 10, 10, 10,  5],\n        [ -5,  0,  0,  0,  0,  0,  0, -5],\n        [ -5,  0,  0,  0,  0,  0,  0, -5],\n        [ -5,  0,  0,  0,  0,  0,  0, -5],\n        [ -5,  0,  0,  0,  0,  0,  0, -5],\n        [ -5,  0,  0,  0,  0,  0,  0, -5],\n        [  0,  0,  0,  5,  5,  0,  0,  0]\n    ],\n    'Q': [\n        [-20,-10,-10, -5, -5,-10,-10,-20],\n        [-10,  0,  0,  0,  0,  0,  0,-10],\n        [-10,  0,  5,  5,  5,  5,  0,-10],\n        [ -5,  0,  5,  5,  5,  5,  0, -5],\n        [  0,  0,  5,  5,  5,  5,  0, -5],\n        [-10,  5,  5,  5,  5,  5,  0,-10],\n        [-10,  0,  5,  0,  0,  0,  0,-10],\n        [-20,-10,-10, -5, -5,-10,-10,-20]\n    ],\n    'K_Mid': [\n        [-30,-40,-40,-50,-50,-40,-40,-30],\n        [-30,-40,-40,-50,-50,-40,-40,-30],\n        [-30,-40,-40,-50,-50,-40,-40,-30],\n        [-30,-40,-40,-50,-50,-40,-40,-30],\n        [-20,-30,-30,-40,-40,-30,-30,-20],\n        [-10,-20,-20,-20,-20,-20,-20,-10],\n        [ 20, 20,  0,  0,  0,  0, 20, 20],\n        [ 20, 30, 10,  0,  0, 10, 30, 20]\n    ],\n    'K_End': [\n        [-50,-40,-30,-20,-20,-30,-40,-50],\n        [-30,-20,-10,  0,  0,-10,-20,-30],\n        [-30,-10, 20, 30, 30, 20,-10,-30],\n        [-30,-10, 30, 40, 40, 30,-10,-30],\n        [-30,-10, 30, 40, 40, 30,-10,-30],\n        [-30,-10, 20, 30, 30, 20,-10,-30],\n        [-30,-30,  0,  0,  0,  0,-30,-30],\n        [-50,-30,-30,-30,-30,-30,-30,-50]\n    ]\n};\n\nfunction getPSTValue(pieceType, x, y, color, isEndgame) {\n    const tableKey = (pieceType === 'K') ? (isEndgame ? 'K_End' : 'K_Mid') : pieceType;\n    const table = piecePSTs[tableKey];\n    if (!table) return 0;\n    const pstRank = (color === 'W') ? 7 - y : y;\n    const pstFile = x;\n    const value = table?.[pstRank]?.[pstFile] ?? 0;\n    return (color === 'W') ? value : -value;\n}\n\nconst pieces = {\"WP\":11, \"WR\":10, \"WN\":9, \"WB\":8, \"WQ\":7, \"WK\":6, \"BP\":5, \"BR\":4, \"BN\":3, \"BB\":2, \"BQ\":1, \"BK\":0};\nconst pieceValues = {\"P\": 100, \"N\": 320, \"B\": 330, \"R\": 500, \"Q\": 900, \"K\": 20000};\nconst CHECKMATE_SCORE = 100000;\nconst DRAW_SCORE = 0;\n\nconst ISOLATED_PAWN_PENALTY = -10;\nconst DOUBLED_PAWN_PENALTY = -10;\nconst BISHOP_PAIR_BONUS = 30;\nconst ROOK_ON_SEVENTH_BONUS = 20;\nconst KING_SAFETY_OPEN_FILE_PENALTY = -15;\n\nlet grid = {};\nlet selectedPiece = \"\";\nlet turn = \"W\";\nlet moves = {};\nlet legalMovesCache = {};\nlet castlingRights = { WQ: true, WK: true, BQ: true, BK: true };\nlet enPassantTarget = null;\nlet moveHistory = [];\nlet gameStatus = \"ongoing\";\nlet isAiThinking = false;\n\nfunction deepCopyState(board, rights, epTarget) {\n    const newGrid = {};\n    for (const coord in board) {\n        newGrid[coord] = { ...board[coord] };\n    }\n    const newRights = { ...rights };\n    return { grid: newGrid, castlingRights: newRights, enPassantTarget: epTarget };\n}\n\nfunction getKingCoord(side, board) {\n    const kingPiece = side + \"K\";\n    for (const coord in board) {\n        if (board[coord]?.piece === kingPiece) {\n            return coord;\n        }\n    }\n    return null;\n}\n\nfunction isSquareAttacked(targetCoord, attackerSide, board) {\n    const [targetX, targetY] = targetCoord.split('x').map(Number);\n    const defenderSide = attackerSide === 'W' ? 'B' : 'W';\n\n    const pawnAttackDir = attackerSide === 'W' ? -1 : 1;\n    const pawnCheckY = targetY - pawnAttackDir;\n    if (pawnCheckY >= 0 && pawnCheckY <= 7) {\n        for (let dx of [-1, 1]) {\n            const pawnCheckX = targetX + dx;\n            if (pawnCheckX >= 0 && pawnCheckX <= 7) {\n                const attackerPawn = board[`${pawnCheckX}x${pawnCheckY}`]?.piece;\n                if (attackerPawn === attackerSide + 'P') return true;\n            }\n        }\n    }\n\n    const knightMoves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]];\n    for (const [dx, dy] of knightMoves) {\n        const knightX = targetX + dx;\n        const knightY = targetY + dy;\n        if (knightX >= 0 && knightX <= 7 && knightY >= 0 && knightY <= 7) {\n            const attackerKnight = board[`${knightX}x${knightY}`]?.piece;\n            if (attackerKnight === attackerSide + 'N') return true;\n        }\n    }\n\n    const kingMoves = [[-1, -1], [1, 1], [-1, 1], [1, -1], [-1, 0], [1, 0], [0, 1], [0, -1]];\n     for (const [dx, dy] of kingMoves) {\n        const kingX = targetX + dx;\n        const kingY = targetY + dy;\n        if (kingX >= 0 && kingX <= 7 && kingY >= 0 && kingY <= 7) {\n            const attackerKing = board[`${kingX}x${kingY}`]?.piece;\n            if (attackerKing === attackerSide + 'K') return true;\n        }\n    }\n\n    const checkLine = (directions, attackingPieceTypes) => {\n        for (const [dx, dy] of directions) {\n            for (let i = 1; i < 8; i++) {\n                const checkX = targetX + dx * i;\n                const checkY = targetY + dy * i;\n                if (checkX < 0 || checkX > 7 || checkY < 0 || checkY > 7) break;\n\n                const pieceOnLine = board[`${checkX}x${checkY}`]?.piece;\n                if (pieceOnLine) {\n                    if (pieceOnLine.startsWith(attackerSide) && attackingPieceTypes.includes(pieceOnLine[1])) {\n                        return true;\n                    }\n                    break;\n                }\n            }\n        }\n        return false;\n    };\n\n    if (checkLine([[-1, 0], [1, 0], [0, 1], [0, -1]], ['R', 'Q'])) return true;\n    if (checkLine([[-1, -1], [1, 1], [-1, 1], [1, -1]], ['B', 'Q'])) return true;\n\n    return false;\n}\n\nfunction isEndgamePhase(board) {\n    let whiteMaterial = 0;\n    let blackMaterial = 0;\n    let queens = 0;\n    for (const coord in board) {\n        const piece = board[coord]?.piece;\n        if (piece) {\n            const type = piece[1];\n            const value = pieceValues[type] || 0;\n            if (piece[0] === 'W') whiteMaterial += value;\n            else blackMaterial += value;\n            if (type === 'Q') queens++;\n        }\n    }\n    const totalMaterial = whiteMaterial + blackMaterial - 2 * pieceValues['K'];\n    return queens === 0 || (queens <= 1 && totalMaterial < 4000) || totalMaterial < 2500;\n}\n\n\nconst chessMain = {\n\n    init() {\n        grid = {};\n        for (let y = 0; y < 8; y++) {\n             for (let x = 0; x < 8; x++) {\n                 let pieceValue = \"\";\n                 if (y == 1) pieceValue = \"BP\";\n                 if (y == 6) pieceValue = \"WP\";\n                 if ((x == 0 || x == 7) && (y == 0)) pieceValue = \"BR\";\n                 if ((x == 0 || x == 7) && (y == 7)) pieceValue = \"WR\";\n                 if ((x == 1 || x == 6) && (y == 0)) pieceValue = \"BN\";\n                 if ((x == 1 || x == 6) && (y == 7)) pieceValue = \"WN\";\n                 if ((x == 2 || x == 5) && (y == 0)) pieceValue = \"BB\";\n                 if ((x == 2 || x == 5) && (y == 7)) pieceValue = \"WB\";\n                 if ((x == 3) && (y == 0)) pieceValue = \"BQ\";\n                 if ((x == 4) && (y == 0)) pieceValue = \"BK\";\n                 if ((x == 3) && (y == 7)) pieceValue = \"WQ\";\n                 if ((x == 4) && (y == 7)) pieceValue = \"WK\";\n                 grid[`${x}x${y}`] = { x: 2 + (x * 18), y: 2 + (y * 18), piece: pieceValue };\n             }\n         }\n        castlingRights = { WQ: true, WK: true, BQ: true, BK: true };\n        enPassantTarget = null;\n        moveHistory = [];\n        gameStatus = \"ongoing\";\n        isAiThinking = false;\n        turn = \"W\";\n        this.generateAllLegalMoves();\n        selectedPiece = \"\";\n        moves = {};\n\n        if (playerMode === 'PvAI' && turn !== playerSide) {\n             this.triggerAIMove();\n        }\n    },\n\n    makeMove(move) {\n        if (!move || !grid[move.from]?.piece || !grid[move.to]) {\n            if(isAiThinking) { isAiThinking = false; }\n            return false;\n        }\n\n        const { from, to, type, promotion } = move;\n        const piece = grid[from].piece;\n        const targetPiece = grid[to].piece;\n\n        const prevEnPassantTarget = enPassantTarget;\n        const prevCastlingRights = { ...castlingRights };\n        let capturedPiece = targetPiece;\n\n        grid[to].piece = piece;\n        grid[from].piece = \"\";\n        enPassantTarget = null;\n\n        if (type === \"castle\") {\n            const rookFromX = (to.split('x')[0] === '6') ? 7 : 0;\n            const rookToX = (to.split('x')[0] === '6') ? 5 : 3;\n            const rank = from.split('x')[1];\n            const rookFromCoord = `${rookFromX}x${rank}`;\n            const rookToCoord = `${rookToX}x${rank}`;\n            grid[rookToCoord].piece = grid[rookFromCoord].piece;\n            grid[rookFromCoord].piece = \"\";\n        } else if (type === \"enpassant\") {\n            const capturedPawnY = from.split('x')[1];\n            const capturedPawnX = to.split('x')[0];\n            const capturedCoord = `${capturedPawnX}x${capturedPawnY}`;\n            capturedPiece = grid[capturedCoord]?.piece;\n            if (grid[capturedCoord]) grid[capturedCoord].piece = \"\";\n        } else if (promotion) {\n            grid[to].piece = piece[0] + promotion;\n        }\n\n        const [fromX, fromY] = from.split('x').map(Number);\n        const [toX, toY] = to.split('x').map(Number);\n        const currentSide = piece[0];\n\n        if (piece[1] === 'P' && Math.abs(fromY - toY) === 2) {\n            const epRank = (currentSide === 'W') ? toY + 1 : toY - 1;\n            enPassantTarget = `${toX}x${epRank}`;\n        }\n\n        if (piece === \"WK\") { castlingRights.WK = false; castlingRights.WQ = false; }\n        else if (piece === \"BK\") { castlingRights.BK = false; castlingRights.BQ = false; }\n        else if (piece === \"WR\") {\n            if (from === \"0x7\") castlingRights.WQ = false; else if (from === \"7x7\") castlingRights.WK = false;\n        } else if (piece === \"BR\") {\n            if (from === \"0x0\") castlingRights.BQ = false; else if (from === \"7x0\") castlingRights.BK = false;\n        }\n        if (targetPiece === \"WR\") {\n             if (to === \"0x7\") castlingRights.WQ = false; else if (to === \"7x7\") castlingRights.WK = false;\n        } else if (targetPiece === \"BR\") {\n             if (to === \"0x0\") castlingRights.BQ = false; else if (to === \"7x0\") castlingRights.BK = false;\n        }\n\n        moveHistory.push({\n            ...move, piece, captured: capturedPiece,\n            prevEPTarget: prevEnPassantTarget,\n            prevCastlingRights: prevCastlingRights\n        });\n\n        this.nextTurn();\n        return true;\n    },\n\n    generateAllLegalMoves() {\n        legalMovesCache = this.getAllAvailableMoves(turn, grid, castlingRights, enPassantTarget, false);\n\n        if (gameStatus === \"ongoing\") {\n            const kingCoord = getKingCoord(turn, grid);\n            const opponentSide = (turn === 'W' ? 'B' : 'W');\n            const isInCheck = kingCoord ? isSquareAttacked(kingCoord, opponentSide, grid) : false;\n\n            let hasLegalMoves = Object.values(legalMovesCache).some(movesArray => movesArray.length > 0);\n\n            if (!hasLegalMoves) {\n                if (isInCheck) {\n                    gameStatus = \"checkmate\";\n                } else {\n                    gameStatus = \"stalemate\";\n                }\n            }\n        }\n    },\n\n    getAllAvailableMoves(side, currentGrid, currentCastlingRights, currentEnPassantTarget, skipCheckValidation = false) {\n        let availableMoves = {};\n        const opponentSide = (side === 'W') ? 'B' : 'W';\n\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                const coord = `${x}x${y}`;\n                const cell = currentGrid[coord];\n                if (!cell || !cell.piece.startsWith(side)) continue;\n\n                const piece = cell.piece;\n                const pieceType = piece[1];\n                availableMoves[coord] = [];\n                const currentX = x;\n                const currentY = y;\n                const potentialMoves = [];\n\n                const checkTarget = (tx, ty, moveProps = {}) => {\n                     if (tx < 0 || tx > 7 || ty < 0 || ty > 7) return null;\n                     const targetCoord = `${tx}x${ty}`;\n                     const targetCell = currentGrid[targetCoord];\n                     if (!targetCell) return null;\n\n                     if (targetCell.piece === \"\") {\n                         return { from: coord, to: targetCoord, ...moveProps };\n                     } else if (!targetCell.piece.startsWith(side)) {\n                         return { from: coord, to: targetCoord, ...moveProps };\n                     }\n                     return null;\n                 };\n\n                const addSlidingMoves = (directions) => {\n                     directions.forEach(([dx, dy]) => {\n                         for (let i = 1; i < 8; i++) {\n                             const targetX = currentX + dx * i;\n                             const targetY = currentY + dy * i;\n                             const move = checkTarget(targetX, targetY);\n                             if (move) {\n                                 potentialMoves.push(move);\n                                 if (currentGrid[`${targetX}x${targetY}`]?.piece) {\n                                     break;\n                                 }\n                             } else {\n                                 break;\n                             }\n                         }\n                     });\n                 };\n\n                 const addSingleStepMoves = (directions) => {\n                      directions.forEach(([dx, dy]) => {\n                          const move = checkTarget(currentX + dx, currentY + dy);\n                          if(move) potentialMoves.push(move);\n                      });\n                  };\n\n                if (pieceType === \"P\") {\n                    const dir = (side === \"W\") ? -1 : 1;\n                    const startRank = (side === \"W\") ? 6 : 1;\n                    const promotionRank = (side === \"W\") ? 0 : 7;\n\n                    const forward1Y = currentY + dir;\n                    const forward1Coord = `${currentX}x${forward1Y}`;\n                    if (forward1Y >= 0 && forward1Y <= 7 && currentGrid[forward1Coord]?.piece === \"\") {\n                        if (forward1Y === promotionRank) {\n                            ['Q', 'R', 'N', 'B'].forEach(p => potentialMoves.push({ from: coord, to: forward1Coord, promotion: p }));\n                        } else {\n                            potentialMoves.push({ from: coord, to: forward1Coord });\n                        }\n                        const forward2Y = currentY + dir * 2;\n                        const forward2Coord = `${currentX}x${forward2Y}`;\n                        if (currentY === startRank && currentGrid[forward2Coord]?.piece === \"\") {\n                            potentialMoves.push({ from: coord, to: forward2Coord });\n                        }\n                    }\n                    for (let dx of [-1, 1]) {\n                        const captureX = currentX + dx;\n                        const captureY = currentY + dir;\n                        if (captureX < 0 || captureX > 7 || captureY < 0 || captureY > 7) continue;\n                        const captureCoord = `${captureX}x${captureY}`;\n                        const targetCell = currentGrid[captureCoord];\n\n                        if (targetCell) {\n                           if (targetCell.piece !== \"\" && targetCell.piece.startsWith(opponentSide)) {\n                               if (captureY === promotionRank) {\n                                   ['Q', 'R', 'N', 'B'].forEach(p => potentialMoves.push({ from: coord, to: captureCoord, promotion: p }));\n                               } else {\n                                   potentialMoves.push({ from: coord, to: captureCoord });\n                               }\n                           }\n                           else if (captureCoord === currentEnPassantTarget && targetCell.piece === \"\") {\n                               potentialMoves.push({ from: coord, to: captureCoord, type: \"enpassant\" });\n                           }\n                        }\n                    }\n                } else if (pieceType === \"R\") {\n                    addSlidingMoves([[-1, 0], [1, 0], [0, 1], [0, -1]]);\n                } else if (pieceType === \"N\") {\n                    addSingleStepMoves([[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]);\n                } else if (pieceType === \"B\") {\n                    addSlidingMoves([[-1, -1], [1, 1], [-1, 1], [1, -1]]);\n                } else if (pieceType === \"Q\") {\n                    addSlidingMoves([[-1, -1], [1, 1], [-1, 1], [1, -1], [-1, 0], [1, 0], [0, 1], [0, -1]]);\n                } else if (pieceType === \"K\") {\n                    addSingleStepMoves([[-1, -1], [1, 1], [-1, 1], [1, -1], [-1, 0], [1, 0], [0, 1], [0, -1]]);\n                    if (!skipCheckValidation) {\n                        const rank = (side === 'W') ? 7 : 0;\n                        const kingStartCoord = `4x${rank}`;\n                        if (coord === kingStartCoord && !isSquareAttacked(coord, opponentSide, currentGrid)) {\n                            const KSCastleRight = side + 'K';\n                            if (currentCastlingRights[KSCastleRight] &&\n                                currentGrid[`5x${rank}`]?.piece === \"\" &&\n                                currentGrid[`6x${rank}`]?.piece === \"\" &&\n                                currentGrid[`7x${rank}`]?.piece === (side + 'R') &&\n                                !isSquareAttacked(`5x${rank}`, opponentSide, currentGrid) &&\n                                !isSquareAttacked(`6x${rank}`, opponentSide, currentGrid)) {\n                                potentialMoves.push({ from: coord, to: `6x${rank}`, type: \"castle\" });\n                            }\n                             const QSCastleRight = side + 'Q';\n                             if (currentCastlingRights[QSCastleRight] &&\n                                 currentGrid[`3x${rank}`]?.piece === \"\" &&\n                                 currentGrid[`2x${rank}`]?.piece === \"\" &&\n                                 currentGrid[`1x${rank}`]?.piece === \"\" &&\n                                 currentGrid[`0x${rank}`]?.piece === (side + 'R') &&\n                                 !isSquareAttacked(`3x${rank}`, opponentSide, currentGrid) &&\n                                 !isSquareAttacked(`2x${rank}`, opponentSide, currentGrid)) {\n                                 potentialMoves.push({ from: coord, to: `2x${rank}`, type: \"castle\" });\n                             }\n                         }\n                    }\n                }\n\n                if (!skipCheckValidation) {\n                    potentialMoves.forEach(move => {\n                        let tempState = deepCopyState(currentGrid, currentCastlingRights, currentEnPassantTarget);\n                        this.applyTemporaryMove(tempState.grid, move, tempState.castlingRights, tempState.enPassantTarget, true);\n                        const kingCoordAfterMove = getKingCoord(side, tempState.grid);\n                        if (kingCoordAfterMove && !isSquareAttacked(kingCoordAfterMove, opponentSide, tempState.grid)) {\n                            availableMoves[coord].push(move);\n                        }\n                    });\n                } else {\n                    availableMoves[coord].push(...potentialMoves);\n                }\n            }\n        }\n        return availableMoves;\n    },\n\n    evalBoard(board, currentTurnCastlingRights) {\n        let totalScore = 0;\n        const endgame = isEndgamePhase(board);\n        let pawnCounts = { W: Array(8).fill(0), B: Array(8).fill(0) };\n        let pieceCounts = { W: {'B': 0}, B: {'B': 0}};\n        let fileHasPawn = { W: Array(8).fill(false), B: Array(8).fill(false) };\n        let whiteKingCoord = null;\n        let blackKingCoord = null;\n\n        for (const coord in board) {\n            const cell = board[coord];\n            if (!cell || cell.piece === \"\") continue;\n\n            const piece = cell.piece;\n            const pieceType = piece[1];\n            const pieceColor = piece[0];\n            const [x, y] = coord.split('x').map(Number);\n\n            const materialValue = pieceValues[pieceType] || 0;\n            totalScore += (pieceColor === 'W') ? materialValue : -materialValue;\n\n            totalScore += getPSTValue(pieceType, x, y, pieceColor, endgame);\n\n            if (pieceType === 'P') {\n                pawnCounts[pieceColor][x]++;\n                fileHasPawn[pieceColor][x] = true;\n            } else if (pieceType === 'B') {\n                pieceCounts[pieceColor]['B']++;\n            } else if (pieceType === 'K') {\n                if (pieceColor === 'W') whiteKingCoord = coord; else blackKingCoord = coord;\n            } else if (pieceType === 'R') {\n                const seventhRankY = (pieceColor === 'W') ? 1 : 6;\n                if (y === seventhRankY) {\n                    totalScore += (pieceColor === 'W') ? ROOK_ON_SEVENTH_BONUS : -ROOK_ON_SEVENTH_BONUS;\n                }\n            }\n        }\n\n        for (let x = 0; x < 8; x++) {\n            if (pawnCounts['W'][x] > 1) totalScore += DOUBLED_PAWN_PENALTY;\n            if (pawnCounts['B'][x] > 1) totalScore -= DOUBLED_PAWN_PENALTY;\n\n            const hasLeftNeighborW = (x > 0) && pawnCounts['W'][x - 1] > 0;\n            const hasRightNeighborW = (x < 7) && pawnCounts['W'][x + 1] > 0;\n            if (pawnCounts['W'][x] > 0 && !hasLeftNeighborW && !hasRightNeighborW) {\n                totalScore += ISOLATED_PAWN_PENALTY;\n            }\n            const hasLeftNeighborB = (x > 0) && pawnCounts['B'][x - 1] > 0;\n            const hasRightNeighborB = (x < 7) && pawnCounts['B'][x + 1] > 0;\n            if (pawnCounts['B'][x] > 0 && !hasLeftNeighborB && !hasRightNeighborB) {\n                totalScore -= ISOLATED_PAWN_PENALTY;\n            }\n        }\n\n        if (pieceCounts['W']['B'] >= 2) totalScore += BISHOP_PAIR_BONUS;\n        if (pieceCounts['B']['B'] >= 2) totalScore -= BISHOP_PAIR_BONUS;\n\n        if (!endgame) {\n            [whiteKingCoord, blackKingCoord].forEach((kCoord, index) => {\n                if (!kCoord) return;\n                const color = (index === 0) ? 'W' : 'B';\n                const opponentColor = (index === 0) ? 'B' : 'W';\n                const [kingX] = kCoord.split('x').map(Number);\n\n                for (let dx = -1; dx <= 1; dx++) {\n                    const fileX = kingX + dx;\n                    if (fileX < 0 || fileX > 7) continue;\n\n                    const isSemiOpenForOpponent = !fileHasPawn[color][fileX];\n                    const isOpen = isSemiOpenForOpponent && !fileHasPawn[opponentColor][fileX];\n\n                    if (isOpen || isSemiOpenForOpponent) {\n                         totalScore += (color === 'W') ? KING_SAFETY_OPEN_FILE_PENALTY : -KING_SAFETY_OPEN_FILE_PENALTY;\n                    }\n                }\n            });\n        }\n\n        return totalScore;\n    },\n\n     scoreMove(move, board, isEndgame) {\n        let score = 0;\n        const movingPiece = board[move.from]?.piece;\n        const capturedPieceDirect = board[move.to]?.piece;\n        if(!movingPiece) return 0;\n\n        const movingPieceType = movingPiece[1];\n        const movingColor = movingPiece[0];\n        let capturedPieceType = null;\n\n        if (capturedPieceDirect) {\n            capturedPieceType = capturedPieceDirect[1];\n        } else if (move.type === 'enpassant') {\n            capturedPieceType = 'P';\n        }\n\n        if (capturedPieceType) {\n            score += 10 * (pieceValues[capturedPieceType] || 0) - (pieceValues[movingPieceType] || 0);\n        }\n\n        if (move.promotion) {\n            score += pieceValues[move.promotion] || 0;\n        }\n\n        const [fromX, fromY] = move.from.split('x').map(Number);\n        const [toX, toY] = move.to.split('x').map(Number);\n        const fromValue = getPSTValue(movingPieceType, fromX, fromY, movingColor, isEndgame);\n        const toValue = getPSTValue(movingPieceType, toX, toY, movingColor, isEndgame);\n        const pstGain = toValue - fromValue;\n        score += pstGain * 0.1;\n\n        return score;\n    },\n\n    generateNoisyMoves(side, board, rights, epTarget) {\n        const allMovesMap = this.getAllAvailableMoves(side, board, rights, epTarget, true);\n        const noisyMoves = [];\n        const promotionRank = (side === 'W') ? 0 : 7;\n\n        for (const startSq in allMovesMap) {\n            allMovesMap[startSq].forEach(move => {\n                const isCapture = board[move.to]?.piece || move.type === 'enpassant';\n                const isPromotion = move.promotion || (board[move.from]?.piece?.[1] === 'P' && parseInt(move.to.split('x')[1]) === promotionRank);\n\n                if (isCapture || isPromotion) {\n                    noisyMoves.push(move);\n                }\n            });\n        }\n        return noisyMoves;\n    },\n\n     quiescenceSearch(board, depth, alpha, beta, maximizingPlayer, currentCastlingRights, currentEnPassantTarget) {\n        const standPatScore = this.evalBoard(board, currentCastlingRights);\n\n        if (maximizingPlayer) {\n            if (standPatScore >= beta) return beta;\n            alpha = Math.max(alpha, standPatScore);\n        } else {\n            if (standPatScore <= alpha) return alpha;\n            beta = Math.min(beta, standPatScore);\n        }\n\n        if (depth <= 0) {\n            return standPatScore;\n        }\n\n        const currentSide = maximizingPlayer ? 'W' : 'B';\n        const noisyMoves = this.generateNoisyMoves(currentSide, board, currentCastlingRights, currentEnPassantTarget);\n        const isEndgame = isEndgamePhase(board);\n\n        noisyMoves.sort((a, b) => this.scoreMove(b, board, isEndgame) - this.scoreMove(a, board, isEndgame));\n\n        for (const move of noisyMoves) {\n            let tempState = deepCopyState(board, currentCastlingRights, currentEnPassantTarget);\n            let newEpTarget = this.applyTemporaryMove(tempState.grid, move, tempState.castlingRights, tempState.enPassantTarget, true);\n\n            let score = this.quiescenceSearch(tempState.grid, depth - 1, alpha, beta, !maximizingPlayer, tempState.castlingRights, newEpTarget);\n\n            if (maximizingPlayer) {\n                alpha = Math.max(alpha, score);\n                if (alpha >= beta) break;\n            } else {\n                beta = Math.min(beta, score);\n                if (beta <= alpha) break;\n            }\n        }\n\n        return maximizingPlayer ? alpha : beta;\n    },\n\n    minimax(board, depth, alpha, beta, maximizingPlayer, currentCastlingRights, currentEnPassantTarget) {\n        const currentSide = maximizingPlayer ? 'W' : 'B';\n        const opponentSide = maximizingPlayer ? 'B' : 'W';\n\n        const allPossibleMovesForCurrent = this.getAllAvailableMoves(currentSide, board, currentCastlingRights, currentEnPassantTarget, false);\n        let hasLegalMoves = Object.values(allPossibleMovesForCurrent).some(m => m.length > 0);\n\n        if (!hasLegalMoves) {\n            const kingCoord = getKingCoord(currentSide, board);\n            const isInCheck = kingCoord ? isSquareAttacked(kingCoord, opponentSide, board) : false;\n            if (isInCheck) {\n                return maximizingPlayer ? (-CHECKMATE_SCORE - depth) : (CHECKMATE_SCORE + depth);\n            } else {\n                return DRAW_SCORE;\n            }\n        }\n\n        if (depth === 0) {\n            return this.quiescenceSearch(board, Q_SEARCH_MAX_DEPTH, alpha, beta, maximizingPlayer, currentCastlingRights, currentEnPassantTarget);\n        }\n\n        const moveList = [];\n        for (const startSq in allPossibleMovesForCurrent) { moveList.push(...allPossibleMovesForCurrent[startSq]); }\n        const isEndgame = isEndgamePhase(board);\n        moveList.sort((a, b) => this.scoreMove(b, board, isEndgame) - this.scoreMove(a, board, isEndgame));\n\n        if (maximizingPlayer) {\n            let maxEval = -Infinity;\n            for (const move of moveList) {\n                let tempState = deepCopyState(board, currentCastlingRights, currentEnPassantTarget);\n                let newEpTarget = this.applyTemporaryMove(tempState.grid, move, tempState.castlingRights, tempState.enPassantTarget, true);\n                let evalScore = this.minimax(tempState.grid, depth - 1, alpha, beta, false, tempState.castlingRights, newEpTarget);\n                maxEval = Math.max(maxEval, evalScore);\n                alpha = Math.max(alpha, evalScore);\n                if (beta <= alpha) {\n                    break;\n                }\n            }\n            return maxEval;\n        } else {\n            let minEval = Infinity;\n            for (const move of moveList) {\n                let tempState = deepCopyState(board, currentCastlingRights, currentEnPassantTarget);\n                let newEpTarget = this.applyTemporaryMove(tempState.grid, move, tempState.castlingRights, tempState.enPassantTarget, true);\n                let evalScore = this.minimax(tempState.grid, depth - 1, alpha, beta, true, tempState.castlingRights, newEpTarget);\n                minEval = Math.min(minEval, evalScore);\n                beta = Math.min(beta, evalScore);\n                if (beta <= alpha) {\n                    break;\n                }\n            }\n            return minEval;\n        }\n    },\n\n    applyTemporaryMove(tempGrid, move, tempRights, currentEpTarget, simulation = false) {\n        const { from, to, type, promotion } = move;\n        if (!tempGrid[from] || !tempGrid[to]) {\n            return currentEpTarget;\n        }\n        const piece = tempGrid[from].piece;\n        if (!piece) {\n            return currentEpTarget;\n        }\n        const targetPiece = tempGrid[to].piece;\n        let nextEpTarget = null;\n\n        tempGrid[to].piece = piece;\n        tempGrid[from].piece = \"\";\n\n        if (type === \"castle\") {\n            const rank = from.split('x')[1];\n            const rookFromX = (to.split('x')[0] === '6') ? 7 : 0;\n            const rookToX = (to.split('x')[0] === '6') ? 5 : 3;\n            const rookFromCoord = `${rookFromX}x${rank}`;\n            const rookToCoord = `${rookToX}x${rank}`;\n            if (tempGrid[rookFromCoord] && tempGrid[rookToCoord]) {\n                tempGrid[rookToCoord].piece = tempGrid[rookFromCoord].piece;\n                tempGrid[rookFromCoord].piece = \"\";\n            }\n        } else if (type === \"enpassant\") {\n            const capturedPawnY = from.split('x')[1];\n            const capturedPawnX = to.split('x')[0];\n            const capturedCoord = `${capturedPawnX}x${capturedPawnY}`;\n            if (tempGrid[capturedCoord]) {\n                 tempGrid[capturedCoord].piece = \"\";\n            }\n        } else if (promotion) {\n            tempGrid[to].piece = piece[0] + promotion;\n        }\n\n        const [fromX, fromY] = from.split('x').map(Number);\n        const [toX, toY] = to.split('x').map(Number);\n        const side = piece[0];\n\n        if (piece[1] === 'P' && Math.abs(fromY - toY) === 2) {\n            const epRank = (side === 'W') ? toY + 1 : toY - 1;\n            nextEpTarget = `${toX}x${epRank}`;\n        }\n\n        if (piece === \"WK\") { tempRights.WK = false; tempRights.WQ = false; }\n        else if (piece === \"BK\") { tempRights.BK = false; tempRights.BQ = false; }\n        else if (piece === \"WR\") {\n            if (from === \"0x7\") tempRights.WQ = false; else if (from === \"7x7\") tempRights.WK = false;\n        } else if (piece === \"BR\") {\n            if (from === \"0x0\") tempRights.BQ = false; else if (from === \"7x0\") tempRights.BK = false;\n        }\n        if (targetPiece === \"WR\") {\n            if (to === \"0x7\") tempRights.WQ = false; else if (to === \"7x7\") tempRights.WK = false;\n        } else if (targetPiece === \"BR\") {\n            if (to === \"0x0\") tempRights.BQ = false; else if (to === \"7x0\") tempRights.BK = false;\n        }\n\n        return nextEpTarget;\n    },\n\n    findBestMove(depth) {\n        isAiThinking = true;\n        this.draw();\n        const startTime = performance.now();\n\n        let bestMoves = [];\n        let bestValue = (turn === 'W') ? -Infinity : Infinity;\n        const currentLegalMoves = legalMovesCache;\n\n        const moveList = [];\n        for (const startSq in currentLegalMoves) { moveList.push(...currentLegalMoves[startSq]); }\n\n        if (moveList.length === 0) {\n            isAiThinking = false;\n            return null;\n        }\n\n        const isEndgameRoot = isEndgamePhase(grid);\n        moveList.sort((a, b) => this.scoreMove(b, grid, isEndgameRoot) - this.scoreMove(a, grid, isEndgameRoot));\n\n        for (const move of moveList) {\n            let tempState = deepCopyState(grid, castlingRights, enPassantTarget);\n            let newEpTarget = this.applyTemporaryMove(tempState.grid, move, tempState.castlingRights, tempState.enPassantTarget, true);\n\n            let boardValue = this.minimax(tempState.grid, depth - 1, -Infinity, Infinity, !(turn === 'W'), tempState.castlingRights, newEpTarget);\n\n            if (turn === 'W') {\n                if (boardValue > bestValue) {\n                    bestValue = boardValue;\n                    bestMoves = [move];\n                } else if (boardValue === bestValue) {\n                    bestMoves.push(move);\n                }\n            } else {\n                if (boardValue < bestValue) {\n                    bestValue = boardValue;\n                    bestMoves = [move];\n                } else if (boardValue === bestValue) {\n                    bestMoves.push(move);\n                }\n            }\n        }\n\n        const endTime = performance.now();\n        isAiThinking = false;\n\n        let chosenMove = null;\n        if (bestMoves.length > 0) {\n             chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];\n        } else {\n             chosenMove = moveList[0];\n        }\n        this.draw();\n        return chosenMove;\n    },\n\n    triggerAIMove() {\n        if (isAiThinking || gameStatus !== 'ongoing') return;\n\n        setTimeout(() => {\n            const aiMove = this.findBestMove(aiDepth);\n\n            if (gameStatus === 'ongoing' && !isAiThinking) {\n                if (aiMove) {\n                    this.makeMove(aiMove);\n                } else {\n                    this.generateAllLegalMoves();\n                }\n            }\n        }, 50);\n    },\n\n    nextTurn() {\n        turn = (turn === \"W\") ? \"B\" : \"W\";\n        selectedPiece = \"\";\n        moves = {};\n\n        this.generateAllLegalMoves();\n\n\n        if (playerMode === 'PvAI' && gameStatus === 'ongoing' && turn !== playerSide) {\n             this.triggerAIMove();\n        } else {\n             selectedPiece = \"\";\n        }\n    },\n\n    draw() {\n        cls(\"brown\");\n        const isPlayerTurnActive = !isAiThinking && gameStatus === 'ongoing' &&\n                                   ((playerMode === 'PvP') || (playerMode === 'PvAI' && turn === playerSide));\n        const opponentSide = (turn === 'W' ? 'B' : 'W');\n\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                const coord = `${x}x${y}`;\n                const cell = grid[coord];\n                if (!cell) continue;\n                const drawX = cell.x;\n                const drawY = cell.y;\n                ctx.fillStyle = ((x + y) % 2 === 0) ? \"#F0D9B5\" : \"#B58863\";\n                ctx.fillRect(drawX, drawY, 18, 18);\n\n                if (cell.piece !== \"\") {\n                    if (pieces[cell.piece] !== undefined) {\n                        ssh(pieces[cell.piece], drawX + 1, drawY + 1, 16, 16);\n                    } else {\n                        ctx.fillStyle = \"magenta\"; ctx.fillRect(drawX + 4, drawY + 4, 10, 10);\n                    }\n                }\n            }\n        }\n\n        const kingInCheckCoord = getKingCoord(turn, grid);\n         if (gameStatus === 'ongoing' && kingInCheckCoord && isSquareAttacked(kingInCheckCoord, opponentSide, grid)) {\n             const kingCell = grid[kingInCheckCoord];\n             ctx.strokeStyle = \"rgba(255, 0, 0, 0.8)\"; ctx.lineWidth = 2;\n             ctx.strokeRect(kingCell.x - 1, kingCell.y - 1, 20, 20);\n         }\n\n        if (isPlayerTurnActive) {\n            if (selectedPiece && grid[selectedPiece]) {\n                const selCell = grid[selectedPiece];\n                ctx.strokeStyle = \"rgba(255, 255, 0, 0.9)\"; ctx.lineWidth = 2;\n                ctx.strokeRect(selCell.x - 1, selCell.y - 1, 20, 20);\n            }\n            if (selectedPiece && moves[selectedPiece]) {\n                 moves[selectedPiece].forEach(move => {\n                     const targetCoord = move.to;\n                     if (!grid[targetCoord]) return;\n                     const moveCell = grid[targetCoord];\n                     const isCapture = grid[targetCoord].piece !== \"\" || move.type === 'enpassant';\n                     ctx.fillStyle = isCapture ? \"rgba(255, 0, 0, 0.4)\" : \"rgba(0, 255, 0, 0.4)\";\n                     ctx.beginPath();\n                     ctx.arc(moveCell.x + 9, moveCell.y + 9, 6, 0, 2 * Math.PI);\n                     ctx.fill();\n                 });\n             }\n        }\n        if (moveHistory.length > 0) {\n            ctx.fillStyle = \"black\";\n            const alpha = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"];\n            const from = moveHistory[moveHistory.length-1].from.split(\"x\");\n            const to = moveHistory[moveHistory.length-1].to.split(\"x\");\n            if (gameStatus !== 'ongoing') {\n                ctx.fillText(`${alpha[parseInt(from[0])]}${8-parseInt(from[1])} > ${alpha[parseInt(to[0])]}${8-parseInt(to[1])}` , 10, 162);\n            } else {\n                ctx.fillText(` , 10, 162);\n            }\n        }\n        ssh((turn == \"W\") ? 12 : 13, 129, 148, 16, 16)\n    },\n\n    update() {\n        this.draw();\n\n        if (gameStatus !== 'ongoing' || isAiThinking) {\n            return;\n        }\n\n        const isPlayerTurnToAct = (playerMode === 'PvP') || (playerMode === 'PvAI' && turn === playerSide);\n\n        if (isPlayerTurnToAct) {\n            for (let y = 0; y < 8; y++) {\n                for (let x = 0; x < 8; x++) {\n                    const coord = `${x}x${y}`;\n                    const cell = grid[coord];\n                    if (!cell) continue;\n                    const clickArea = { x: cell.x, y: cell.y, w: 18, h: 18 };\n\n                    if (clk(clickArea)) {\n                        if (selectedPiece) {\n                            const possibleMove = moves[selectedPiece]?.find(m => m.to === coord);\n                            if (possibleMove) {\n                                this.makeMove(possibleMove);\n                            } else {\n                                if (cell.piece.startsWith(turn)) {\n                                    selectedPiece = coord;\n                                    moves = { [coord]: legalMovesCache[coord] || [] };\n                                } else {\n                                    selectedPiece = \"\";\n                                    moves = {};\n                                }\n                            }\n                        } else {\n                            if (cell.piece.startsWith(turn)) {\n                                selectedPiece = coord;\n                                moves = { [coord]: legalMovesCache[coord] || [] };\n                            }\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n    }\n};\n\nconst chessPieces = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAwCAMAAADZyI/9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJUExURQAAAP///wAAAHPGg3EAAAADdFJOU///ANfKDUEAAAAJcEhZcwAADsEAAA7BAbiRa+0AAAInSURBVFhHvVaLkuMwCHP2/z96h4dAgNOeb5JlOk2EQQLspF0/amutZXduDXa8riscknvppyfpqn1LAq8ywcRLEiJ+Xdcl63LJkFj1GMkojgJrB1YsEgRKeSKRXYWYXLJFMIUgeMtIhIkUHJFkK7i2qL17QOHgglGSO8K2AhlupCpn9SAFmO49KehKA2VEvqoZEIoEnxP0ALIE0A3+gEOARlqKjpSo/mGBZJDBnAsko83e9gxBRpAMjbELMN4QpmRWWM4IIu4ESsfRLmlCL0/CB4ItpnR/Dtjj28FDoZl+IxQctu2AN8VTage5bM9Bn8DsIB3q4Y6cAbDmx2NY8eigOr7jhK7fcLWN6x+Mj+wXQ1wX/4z1INCavBf1Mg1T6CW14LpuUw+HnrFyzij/RqDj/oNTFPoxLfly0QOmhw2eCCAOLlif+hSYe1wEEI6Dqz84CvIcUX12j+h01Z5pRN5udO1aXKRxJsgSwDL4qYMugHooBz06iqBHBSbDmQAxjncLCIihMXYBwvNlRy1khfWMoOuKG3SHlVwJoZeUHwi2mNJVoBK2tysoRgN7wr6+6SBgUtQORscjnATtq1YAOBw36x0X2/ketVS/sZ5wavwDqWPsuCecmr1Ikz3+4+mfipcFxP+SgKN6+v/PPgjYfU84NQjg67UOqsALe/DHAs+PyOp9cZN3Ag924Oz+/+jxPbBSUTEJqLMnnBrmDRu4J5xajOPOesKp/QKzqxc8nk0WlwAAAABJRU5ErkJggg==\";\n\n\nconst chessConfig = {\n    showBox(x, y, w, h, text, varToChange) {\n        if (clk({x:x , y:y , w:w , h:h})) {\n            window[varToChange] = (!isNaN(parseInt(text))) ? parseInt(text) : text;\n            if (varToChange == \"playerMode\") {\n                lvl(1);\n            }\n        }\n        const intX = Math.round(x);\n        const intY = Math.round(y);\n        const intW = Math.round(w);\n        const intH = Math.round(h);\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(intX, intY, intW, intH);\n        ctx.strokeStyle = (text == window[varToChange] && varToChange != \"playerMode\") ? \"yellow\" : \"black\";\n        ctx.lineWidth = 2;\n        ctx.strokeRect(intX, intY, intW, intH);\n        ctx.fillStyle = \"black\";\n        ctx.font = \"16px CustomFont\";\n        const textWidth = ctx.measureText(`${text}`).width;\n        const textX = Math.round(intX + (intW - textWidth) / 2);\n        const textY = Math.round(intY + intH / 2 + 5);\n        ctx.fillText(`${text}`, textX, textY);\n    },\n    showOptions() {\n        this.showBox(12, 6, 124, 20, \"Player Side\");\n        this.showBox(77, 32, 48, 20, \"W\", \"playerSide\");\n        this.showBox(23, 32, 48, 20, \"B\", \"playerSide\");\n        this.showBox(12, 58, 124, 20, \"Difficulty\");\n        this.showBox(32, 84, 24, 20, 1, \"aiDepth\");\n        this.showBox(62, 84, 24, 20, 2, \"aiDepth\");\n        this.showBox(92, 84, 24, 20, 3, \"aiDepth\");\n        this.showBox(12, 114, 124, 20, \"Play\");\n        this.showBox(77, 140, 48, 20, \"PvP\", \"playerMode\");\n        this.showBox(23, 140, 48, 20, \"PvAI\", \"playerMode\");\n    },\n    init() {\n      \n    },\n    update(delta) {\n        cls(\"brown\");\n        this.showOptions();\n    }\n};\n\ngameFramework({\n    width: 148,\n    height: 166,\n    spritesheet: [chessPieces, 6, 3],\n    levels: [chessConfig, chessMain]\n});"
        },
        "Text Adventure Games": {
            "Tutorial": "J:window.adventureGameText = `\n\n[[Welcome]]:\n@clear\nThis is a simple Framework that I have created which allows you to make Text Adventure games as simply as possible.\n\nThis is played via going through sections of text such as this one and providing several options and paths for the reader to take for unique story-telling, such as the button below.\n\n[[Welcome1]](Continue)\n\n[[Welcome1]]:\n@clear\nIt's as easy as that. Below are some more links that each showcase a different aspect of this Framework that allows you to create your own stories from scratch.\n\n[[Getting Started]]\n[[Sections and Passages]]\n[[Re-enabling Sections and Passages]]\n[[Clearing the Screen]]\n[[Using JavaScript]]\n[[Using Variables]]\n[[Variable Integration]]\n[[Asking for Input]]\n[[Turn Counting]]\n\n[[Getting Started]]:\n@show Welcome1\n@clear\nTo start you'll need an area to create and run custom JavaScript code.\n\nAfter this you'll need to call the function \"textAdventure(STR)\" where STR is a multi-line string. This is where you'll be writing the stories and games.\n\n[[Sections and Passages]]:\n@show Welcome1\n@clear\nSections and Passages\n\n[[Re-enabling Sections and Passages]]:\n@show Welcome1\n@clear\nRe-enabling Sections and Passages\n\n[[Clearing the Screen]]:\n@show Welcome1\n@clear\nClearing the Screen\n\n[[Using JavaScript]]:\n@show Welcome1\n@clear\nUsing JavaScript\n\n[[Using Variables]]:\n@show Welcome1\n@clear\nUsing Variables\n\n[[Variable Integration]]:\n@show Welcome1\n@clear\nVariable Integration\n\n[[Asking for Input]]:\n@show Welcome1\n@clear\nAsking for Input\n\n[[Turn Counting]]:\n@show Welcome1\n@clear\nTurn Counting\n`;\n\ntextAdventure(adventureGameText);\n\n\n\n\n\n\n\n\n\n\n/*\n@clear\n@show Passage1\n@JS CustomJS\n@set Var1 Val1\n@inc Var1 Val2\n@dec Var1 Val2\n@prompt Var1 CustomTextToDisplay\n@Number PassageToShowAfterNumberPassagesShown \n[[Section1]]:\n[Passage1]:\n[[Section1]](Custom Text)\n[Passage1](Custom Text)\n[Passage1, Var1=Val1](Custom Text)\n[Passage1, Var1==Val1, IfFalsePassage](Custom Text)\n\n*/"
        },
        "Test Platformer": "J:showOption();\noutputArea.style.height = \"100%\";\noutputArea.innerHTML = `<iframe frameborder=\"0\" src=\"https://itch.io/embed-upload/13324018?color=333333\" allowfullscreen=\"\" style=\"margin: 10px; border: 5px solid black; width: calc(100% - 30px); min-height: calc(100% - 30px); border-radius: 8px;\"><a href=\"https://clarkekent.itch.io/platformertest\">Play PlatformerTest on itch.io</a></iframe>`;\n"
    },
    "Study": {
        "Maths": "J:studyFramework(\"Maths\", {\n    \"Algebra I\": [\n        [\"What is an algebraic expression?\", \"Reveal\", \"An algebraic expression is a combination of numbers (constants), variables (represented by letters), and mathematical operations (such as addition, subtraction, multiplication, division, and exponentiation) that does not contain an equals sign. It represents a mathematical quantity or relationship but does not state that it is equal to anything else. The goal with algebraic expressions is often to simplify them, evaluate them for specific values of the variables, or manipulate them in some way.<br>For example : \\(a^2 - 2ab +b^2\\)\"],\n        [\"What is the primary goal of simplifying an algebraic expression?\", \"To rewrite the expression in it's most compact and understandable form.\", \"To find the value of the variable.\", \"To make the expression longer and more complex.\", \"To introduce new variables into the expression.\", \"Simplifying an algebraic expression involves combining like terms and applying the order of operations to make the expression easier to work with and understand, not necessarily to solve for a specific variable.\"],\n        []\n    ],\n    \"Geometry\": [],\n    \"Algebra II\": [],\n    \"Trigonometry\": [],\n    \"Precalculus\": [],\n    \"Calculus I\": [],\n    \"Calculus II\": [],\n    \"Calculus III\": [],\n    \"Linear Algebra\": [],\n    \"Differential Equations\": [],\n    \"Real Analysis\": [],\n    \"Abstract Algebra\": [],\n    \"Complex Analysis\": [],\n    \"Probability and Statistics\": [],\n    \"Topology\": [],\n    \"Number Theory\": [],\n    \"Discrete Mathematics\": [],\n    \"Numerical Analysis\": []\n});",
        "Physics": "J:studyFramework(\"Physics\", {\n    \"Motion and Forces\" : [],\n    \"Energy and Heat\" : [],\n    \"Light and Sound\" : [],\n    \"Electricity and Magnetism\" : [],\n    \"Classical Mechanics\" : [],\n    \"Thermodynamics\" : [],\n    \"Waves and Optics\" : [],\n    \"Electromagnetism\" : [],\n    \"Modern Physics\" : [],\n    \"Advanced Classical Mechanics\" : [],\n    \"Electrodynamics\" : [],\n    \"Quantum Mechanics\" : [],\n    \"Statistical Mechanics\" : [],\n    \"Solid-State Physics\" : [],\n    \"Nuclear and Particle Physics\" : [],\n    \"Astrophysics and Cosmology\" : [],\n    \"General Relativity\" : [],\n    \"Quantum Field Theory\" : [],\n    \"String Theory\" : []\n});",
        "Biology": "J:studyFramework(\"Biology\", {\n    \"Cell Biology I\": [],\n    \"Classification of Living Things\": [],\n    \"Basic Human Biology\": [],\n    \"Ecology I\": [],\n    \"Cell Biology II\": [],\n    \"Ecology II\": [],\n    \"Genetics I\": [],\n    \"Evolution I\": [],\n    \"Plant Biology\": [],\n    \"Animal Biology\": [],\n    \"Molecular Biology\": [],\n    \"Microbiology\": [],\n    \"Physiology\": [],\n    \"Biochemistry\": [],\n    \"Genetics II\": [],\n    \"Ecology III\": [],\n    \"Evolution II\": [],\n    \"Neurobiology\": [],\n    \"Immunology\": [],\n    \"Development Biology\": [],\n    \"Bioinformatics\": [],\n    \"Biophysics\": []\n});",
        "Car Mechanics": "J:studyFramework(\"Car Mechanics\", {\n        \"Engine Fundamentals\": [],\n        \"Fuel Systems\": [],\n        \"Ignition Systems\": [],\n        \"Emission Control Systems\": [],\n        \"Transmissions\": [],\n        \"Drive Systems\": [],\n        \"Hydraulic Brake Systems\": [],\n        \"Anti-lock Braking Systems (ABS)\": [],\n        \"Parking Brakes\": [],\n        \"Suspension Systems\": [],\n        \"Steering Systems\": [],\n        \"Electrical Systems\": [],\n        \"Heating and Air  Conditioning (HVAC)\": [],\n        \"Safety Systems\": [],\n        \"General Systems\": [],\n        \"General Maintenance\": [],\n        \"Electric Vehicles\": [],\n        \"Hybrid Vehicles\": [],\n        \"Advanced Driver-Assistance Systems (ADAS)\": []\n});",
        "First Aid": "J:studyFramework(\"First Aid\", {\n    \"CPR\": [],\n    \"AED\": [],\n    \"Chocking\": [],\n    \"Severe Bleeding\": [],\n    \"Anaphylaxis Shock\": [],\n    \"Wounds\": [],\n    \"Burns\": [],\n    \"Bone Injuries\": [],\n    \"Head Injuries\": [],\n    \"Heart Attack\": [],\n    \"Stroke\": [],\n    \"Seizures\": [],\n    \"Fainting\": [],\n    \"Diabetic Emergencies\": [],\n    \"Asthma Attacks\": [],\n    \"Poisoning\": [],\n    \"Bites\": []\n});",
        "IT": "J:studyFramework(\"IT\", {\n    \"Component Hardware\": [\n        [\"What is Computer Hardware\", \"Reveal\", \"Computer Hardware refers to the physical components that a computer system requires to function. These are the tangible parts you can see and touch, as opposed to software, which are the programs and data.\"],\n        [\"What does CPU stand for?\", \"Reveal\", \"Central Processing Unit\"],\n        [\"What is the primary function of the CPU?\", \"Reveal\", \"To execute program instructions and perform calculations (the 'brain' of the computer).\"],\n        [\"What does RAM stand for?\", \"Reveal\", \"Random Access Memory\"],\n        [\"Is RAM volatile or non-volatile memory?\", \"Reveal\", \"Volatile (data is lost when power is turned off).\"],\n        [\"What is the main circuit board that connects all internal components?\", \"Reveal\", \"Motherboard (also called Mainboard or Mobo).\"],\n        [\"Name two common types of persistent storage drives.\", \"Reveal\", \"Hard Disk Drive (HDD) and Solid State Drive (SSD).\"],\n        [\"Which is generally faster and has no moving parts, HDD or SSD?\", \"Reveal\", \"SSD (Solid State Drive).\"],\n        [\"What does PSU stand for?\", \"Reveal\", \"Power Supply Unit\"],\n        [\"What is the function of the PSU?\", \"Reveal\", \"To convert AC power from the wall outlet to the DC power needed by computer components.\"],\n        [\"What unit typically measures the capacity of a PSU?\", \"Reveal\", \"Watts (W).\"],\n        [\"What does GPU stand for?\", \"Reveal\", \"Graphics Processing Unit\"],\n        [\"What is the primary role of a dedicated GPU?\", \"Reveal\", \"To process and render complex images, video, and animations, primarily for display output and graphical tasks.\"],\n        [\"What firmware initializes hardware during the boot process before the OS loads?\", \"Reveal\", \"BIOS (Basic Input/Output System) or its modern successor, UEFI (Unified Extensible Firmware Interface).\"],\n        [\"What does POST stand for in the context of booting?\", \"Reveal\", \"Power-On Self-Test (a diagnostic check run by the BIOS/UEFI during startup).\"],\n        [\"What term refers to the physical size and shape standard for components like motherboards and computer cases?\", \"Reveal\", \"Form Factor (e.g., ATX, Micro-ATX, ITX).\"],\n        [\"What type of port is commonly used for connecting peripherals like keyboards, mice, printers, and external drives?\", \"Reveal\", \"USB (Universal Serial Bus)\"],\n        [\"What type of port is primarily used for digital video and audio output to monitors or TVs?\", \"Reveal\", \"HDMI (High-Definition Multimedia Interface) or DisplayPort.\"],\n        [\"What type of storage drive uses spinning magnetic platters and read/write heads?\", \"Reveal\", \"HDD (Hard Disk Drive).\"],\n        [\"What type of fast memory is built directly into or very close to the CPU core?\", \"Reveal\", \"Cache Memory (e.g., L1, L2, L3 cache).\"],\n        [\"What component draws heat away from the CPU or GPU?\", \"Reveal\", \"Heatsink (often aided by a fan or liquid cooling system).\"],\n        [\"What does NIC stand for?\", \"Reveal\", \"Network Interface Card (or Controller), used for connecting to a network (wired or wireless).\"],\n        [\"What is the name for the slots on the motherboard used to install RAM modules?\", \"Reveal\", \"DIMM slots (Dual In-line Memory Module).\"],\n        [\"What type of connector on the motherboard is used for high-speed expansion cards like GPUs?\", \"Reveal\", \"PCIe (Peripheral Component Interconnect Express) slot.\"],\n        [\"What type of interface is commonly used to connect internal HDDs and SSDs to the motherboard?\", \"Reveal\", \"SATA (Serial AT Attachment) or NVMe (Non-Volatile Memory Express) for faster SSDs.\"],\n        [\"What are common examples of input devices?\", \"Reveal\", \"Keyboard, Mouse, Scanner, Microphone, Webcam.\"],\n        [\"What are common examples of output devices?\", \"Reveal\", \"Monitor, Printer, Speakers, Projector.\"]\n    ],\n    \"Operating Systems\": [\n        [\"What is the primary role of an Operating System (OS)?\", \"Reveal\", \"To manage computer hardware resources, provide services for application software, and act as an interface between the user and the hardware.\"],\n        [\"What is the core component of an OS that directly manages the system's resources (CPU, memory, devices)?\", \"Reveal\", \"The Kernel.\"],\n        [\"Name the two main types of user interfaces provided by operating systems.\", \"Reveal\", \"Graphical User Interface (GUI) and Command-Line Interface (CLI).\"],\n        [\"What is 'process management' in the context of an OS?\", \"Reveal\", \"The OS function responsible for creating, scheduling, terminating, and managing processes (running instances of programs).\"],\n        [\"What is 'memory management' in the context of an OS?\", \"Reveal\", \"The OS function responsible for allocating and deallocating memory space for processes, keeping track of memory usage, and managing virtual memory.\"],\n        [\"What technique allows an OS to use secondary storage (like an SSD or HDD) as an extension of physical RAM?\", \"Reveal\", \"Virtual Memory (often implemented using paging or segmentation).\"],\n        [\"What OS component is responsible for organizing and managing files and directories on storage devices?\", \"Reveal\", \"The File System (examples: NTFS, FAT32, ext4, APFS).\"],\n        [\"How does the OS communicate with and control specific hardware components?\", \"Reveal\", \"Through Device Drivers, which are specialized software modules.\"],\n        [\"What term describes the ability of an OS to allow multiple programs to appear to run simultaneously on a single CPU core?\", \"Reveal\", \"Multitasking (or Concurrency).\"],\n        [\"What term describes the ability of an OS to execute multiple processes or threads truly simultaneously using multiple CPU cores?\", \"Reveal\", \"Multiprocessing.\"],\n        [\"Name three major families or examples of desktop operating systems.\", \"Reveal\", \"Microsoft Windows, Apple macOS, Linux (e.g., Ubuntu, Fedora, Debian).\"],\n        [\"Name two major mobile operating systems.\", \"Reveal\", \"Google Android, Apple iOS.\"],\n        [\"What is the 'shell' in an operating system?\", \"Reveal\", \"A program that provides the user interface (often CLI, but can be graphical) for accessing the OS services and running commands.\"],\n        [\"What mechanism does an OS use to control access rights (read, write, execute) to files and directories?\", \"Reveal\", \"Permissions (or Access Control).\"],\n        [\"What is the software that loads the main operating system kernel into memory after the initial hardware startup (POST)?\", \"Reveal\", \"The Bootloader (e.g., GRUB, LILO, Windows Boot Manager).\"],\n        [\"What is a 'thread' within the context of an OS?\", \"Reveal\", \"A lightweight unit of execution within a process. Multiple threads can run within a single process, sharing its resources.\"],\n        [\"How do application programs typically request services from the OS kernel?\", \"Reveal\", \"Through System Calls, which are specific interfaces provided by the kernel.\"],\n        [\"What is an 'interrupt'?\", \"Reveal\", \"A signal generated by hardware or software to indicate an event that requires the immediate attention of the CPU/kernel.\"],\n        [\"What does API stand for, and how does it relate to an OS?\", \"Reveal\", \"Application Programming Interface. It defines how software components should interact; OS APIs allow applications to use OS functions (like file access or network communication).\"],\n        [\"Which major operating system family is known for being open-source and having many different 'distributions'?\", \"Reveal\", \"Linux.\"]\n    ],\n    \"Networking\": [\n        [\"What is a computer network?\", \"Reveal\", \"A collection of two or more computers and devices connected together to share resources (like files, printers) and communicate.\"],\n        [\"What does LAN stand for and what does it typically cover?\", \"Reveal\", \"Local Area Network. It typically covers a small geographic area, like a single building, office, or home.\"],\n        [\"What does WAN stand for and what does it typically cover?\", \"Reveal\", \"Wide Area Network. It covers a large geographic area, often connecting multiple LANs across cities or countries (e.g., the Internet).\"],\n        [\"What is the most common physical network topology in modern wired LANs?\", \"Reveal\", \"Star Topology, where devices connect to a central point like a switch.\"],\n        [\"What are the two primary conceptual models describing network protocol layers?\", \"Reveal\", \"The OSI (Open Systems Interconnection) model and the TCP/IP model.\"],\n        [\"Which layer of the OSI model is responsible for logical addressing (IP) and routing packets between networks?\", \"Reveal\", \"Layer 3 - The Network Layer.\"],\n        [\"Which layer of the OSI model handles process-to-process communication using protocols like TCP and UDP?\", \"Reveal\", \"Layer 4 - The Transport Layer.\"],\n        [\"What does TCP stand for, and is it connection-oriented or connectionless?\", \"Reveal\", \"Transmission Control Protocol. It is connection-oriented, providing reliable, ordered delivery.\"],\n        [\"What does UDP stand for, and is it connection-oriented or connectionless?\", \"Reveal\", \"User Datagram Protocol. It is connectionless, offering faster but less reliable delivery.\"],\n        [\"What does IP stand for, and what is its fundamental role?\", \"Reveal\", \"Internet Protocol. It's responsible for addressing hosts and routing datagrams (packets) across networks.\"],\n        [\"What service translates human-readable domain names (like 'www.google.com') into IP addresses?\", \"Reveal\", \"DNS (Domain Name System).\"],\n        [\"What service automatically assigns IP addresses, subnet masks, and default gateway information to client devices?\", \"Reveal\", \"DHCP (Dynamic Host Configuration Protocol).\"],\n        [\"What is the key difference in address space size between IPv4 and IPv6?\", \"Reveal\", \"IPv4 uses 32-bit addresses (approx. 4.3 billion), while IPv6 uses 128-bit addresses (a vastly larger number).\"],\n        [\"What network device operates at Layer 3 (Network Layer) to connect different networks and forward traffic between them based on IP addresses?\", \"Reveal\", \"Router.\"],\n        [\"What network device operates primarily at Layer 2 (Data Link Layer) to connect devices within the *same* LAN and forwards traffic based on MAC addresses?\", \"Reveal\", \"Switch.\"],\n        [\"What is the purpose of a Subnet Mask?\", \"Reveal\", \"It's used alongside an IP address to identify the network portion and the host portion of the address.\"],\n        [\"What is the role of the 'Default Gateway' in IP configuration?\", \"Reveal\", \"It's the IP address of the router on the local network that devices send traffic to when the destination is outside their own network segment.\"],\n        [\"What does NIC stand for?\", \"Reveal\", \"Network Interface Card (or Controller). The hardware component that allows a device to connect to a network.\"],\n        [\"What is a MAC address?\", \"Reveal\", \"Media Access Control address. A unique physical address burned into each NIC by the manufacturer.\"],\n        [\"What does SSID stand for in the context of Wi-Fi?\", \"Reveal\", \"Service Set Identifier. It's the public name of a wireless network.\"],\n        [\"Name a widely used security protocol for encrypting Wi-Fi networks.\", \"Reveal\", \"WPA2 (Wi-Fi Protected Access 2) or the more recent WPA3.\"],\n        [\"What type of cabling is most commonly used for wired Ethernet LANs?\", \"Reveal\", \"Twisted Pair cable (e.g., Cat 5e, Cat 6, Cat 6a).\"],\n        [\"What command-line tool is used to test network connectivity to a specific host by sending ICMP echo requests?\", \"Reveal\", \"ping.\"],\n        [\"What command-line tool displays the IP network configuration on Windows?\", \"Reveal\", \"ipconfig.\"],\n        [\"What command-line tool typically displays IP network configuration on Linux or macOS?\", \"Reveal\", \"ifconfig (older) or ip addr (newer).\"],\n        [\"What protocol forms the basis of data communication for the World Wide Web?\", \"Reveal\", \"HTTP (Hypertext Transfer Protocol).\"],\n        [\"What is the secure, encrypted version of HTTP?\", \"Reveal\", \"HTTPS (Hypertext Transfer Protocol Secure).\"],\n        [\"What is a Firewall in networking?\", \"Reveal\", \"A network security device or software that monitors and controls incoming and outgoing network traffic based on predetermined security rules.\"]\n    ],\n    \"Cybersecurity I\": [\n        [\"What are the three core principles of the CIA Triad in information security?\", \"Reveal\", \"Confidentiality, Integrity, and Availability.\"],\n        [\"What does 'Confidentiality' mean in the CIA Triad?\", \"Reveal\", \"Ensuring that information is not accessed by unauthorized individuals or systems.\"],\n        [\"What does 'Integrity' mean in the CIA Triad?\", \"Reveal\", \"Ensuring that data is accurate, complete, and has not been tampered with or altered without authorization.\"],\n        [\"What does 'Availability' mean in the CIA Triad?\", \"Reveal\", \"Ensuring that systems, networks, and data are accessible and operational for authorized users when needed.\"],\n        [\"What is a 'vulnerability' in cybersecurity?\", \"Reveal\", \"A weakness or flaw in a system, application, or process that could be exploited by a threat.\"],\n        [\"What is a 'threat' in cybersecurity?\", \"Reveal\", \"Any potential danger or event that could harm an asset by exploiting a vulnerability (e.g., malware, hacker, natural disaster).\"],\n        [\"What is 'risk' in cybersecurity?\", \"Reveal\", \"The likelihood that a specific threat will exploit a specific vulnerability, combined with the potential impact or damage.\"],\n        [\"What is 'malware'?\", \"Reveal\", \"Malicious Software: Software intentionally designed to cause damage, disrupt operations, or gain unauthorized access to a computer system.\"],\n        [\"What is a computer 'virus'?\", \"Reveal\", \"A type of malware that attaches itself to legitimate programs or files and requires human action (like running the program) to spread.\"],\n        [\"What is a computer 'worm'?\", \"Reveal\", \"A type of self-replicating malware that can spread across networks automatically without user intervention, often exploiting vulnerabilities.\"],\n        [\"What is a 'Trojan Horse' in malware terms?\", \"Reveal\", \"Malware disguised as legitimate software. It tricks users into installing it, then performs malicious actions in the background.\"],\n        [\"What does 'Ransomware' typically do?\", \"Reveal\", \"Encrypts a victim's files or locks their system, demanding a ransom payment (often cryptocurrency) for decryption or unlocking.\"],\n        [\"What is 'Spyware'?\", \"Reveal\", \"Malware designed to secretly monitor and collect information about a user's activities without their knowledge or consent.\"],\n        [\"What is 'Social Engineering'?\", \"Reveal\", \"The psychological manipulation of people into performing actions or divulging confidential information.\"],\n        [\"What is 'Phishing'?\", \"Reveal\", \"A common social engineering attack, usually via email, designed to trick victims into revealing sensitive information (like passwords or credit card numbers) by pretending to be a trustworthy entity.\"],\n        [\"What is 'Authentication'?\", \"Reveal\", \"The process of verifying the identity of a user, system, or service.\"],\n        [\"What is the most basic form of authentication?\", \"Reveal\", \"Something you know, typically a username and password combination.\"],\n        [\"What is the basic function of a network 'Firewall'?\", \"Reveal\", \"To monitor and filter incoming and outgoing network traffic based on predefined security rules, acting as a barrier between a trusted internal network and untrusted external networks.\"],\n        [\"What is the primary purpose of 'Antivirus' or 'Antimalware' software?\", \"Reveal\", \"To detect, prevent, quarantine, and remove malicious software from computer systems.\"],\n        [\"Why is 'Patch Management' crucial for security?\", \"Reveal\", \"It involves regularly applying updates (patches) to software and operating systems to fix known vulnerabilities, reducing the attack surface.\"],\n        [\"What is 'Encryption' in simple terms?\", \"Reveal\", \"The process of converting plain text data into a scrambled, unreadable format (ciphertext) using an algorithm and a key, to ensure confidentiality.\"]\n    ],\n    \"Software Development\": [\n        [\"What does SDLC stand for?\", \"Reveal\", \"Software Development Life Cycle.\"],\n        [\"Name at least three distinct phases of a typical SDLC.\", \"Reveal\", \"Examples: Planning, Requirements Analysis, Design, Implementation (Coding), Testing, Deployment, Maintenance.\"],\n        [\"What is the core difference between the Waterfall and Agile development methodologies?\", \"Reveal\", \"Waterfall is a linear, sequential process where each phase completes before the next begins. Agile is iterative and incremental, emphasizing flexibility, collaboration, and responding to change.\"],\n        [\"What is Scrum?\", \"Reveal\", \"A popular Agile framework that uses fixed-length iterations called sprints, specific roles (like Scrum Master, Product Owner), and ceremonies (like Daily Stand-ups, Sprint Reviews).\"],\n        [\"What is Object-Oriented Programming (OOP)?\", \"Reveal\", \"A programming paradigm based on the concept of 'objects', which encapsulate data (attributes) and behavior (methods).\"],\n        [\"Name two fundamental principles of OOP.\", \"Reveal\", \"Examples: Encapsulation, Inheritance, Polymorphism, Abstraction.\"],\n        [\"What is a 'variable' in programming?\", \"Reveal\", \"A named storage location in memory that holds a data value, which can potentially be changed during program execution.\"],\n        [\"What is the purpose of 'control structures' (like loops and conditionals)?\", \"Reveal\", \"To control the order and flow of execution of statements within a program based on conditions or repetitions.\"],\n        [\"Name two common programming languages and a typical application area for each.\", \"Reveal\", \"Examples: Python (web development, data science, scripting), JavaScript (front-end web development, Node.js backend), Java (enterprise applications, Android development), C# (.NET applications, game development).\"],\n        [\"What is the primary purpose of a Version Control System (VCS) like Git?\", \"Reveal\", \"To track changes to source code and other project files over time, enabling collaboration, branching, merging, and history tracking.\"],\n        [\"In Git, what does the 'commit' command do?\", \"Reveal\", \"It saves the current staged changes to the local repository, creating a new snapshot in the project's history.\"],\n        [\"In Git, what does the 'push' command do?\", \"Reveal\", \"It uploads local repository commits (and associated objects) to a remote repository (like GitHub or GitLab).\"],\n        [\"What is 'Unit Testing'?\", \"Reveal\", \"Testing individual, isolated parts (units or components) of the software, such as functions or methods, to ensure they work correctly.\"],\n        [\"What is 'User Acceptance Testing' (UAT)?\", \"Reveal\", \"The final phase of testing where end-users test the software in a realistic environment to ensure it meets their business requirements before deployment.\"],\n        [\"What does API stand for?\", \"Reveal\", \"Application Programming Interface.\"],\n        [\"What is the main function of an API?\", \"Reveal\", \"To define how different software components or systems should interact and exchange data with each other.\"],\n        [\"What does IDE stand for?\", \"Reveal\", \"Integrated Development Environment.\"],\n        [\"What typically constitutes an IDE?\", \"Reveal\", \"A software application providing comprehensive facilities like a source code editor, build automation tools, and a debugger.\"],\n        [\"What is the difference between compilation and interpretation?\", \"Reveal\", \"Compiled code is translated into machine code before runtime by a compiler. Interpreted code is executed line-by-line at runtime by an interpreter.\"]\n    ],\n    \"Cloud Computing\": [\n        [\"What is Cloud Computing?\", \"Reveal\", \"The delivery of on-demand computing services—including servers, storage, databases, networking, software, analytics, and intelligence—over the Internet ('the cloud').\"],\n        [\"Name three key characteristics of cloud computing.\", \"Reveal\", \"Examples: On-demand self-service, Broad network access, Resource pooling, Rapid elasticity, Measured service.\"],\n        [\"What does IaaS stand for?\", \"Reveal\", \"Infrastructure as a Service.\"],\n        [\"In the IaaS model, what does the customer typically manage?\", \"Reveal\", \"The operating systems, middleware, applications, and data. The cloud provider manages the underlying physical infrastructure.\"],\n        [\"What does PaaS stand for?\", \"Reveal\", \"Platform as a Service.\"],\n        [\"What does PaaS typically provide to users?\", \"Reveal\", \"A platform (including OS, programming language execution environment, database, web server) for developing, deploying, and managing applications without managing the underlying infrastructure.\"],\n        [\"What does SaaS stand for?\", \"Reveal\", \"Software as a Service.\"],\n        [\"Give an example of a SaaS application.\", \"Reveal\", \"Examples: Microsoft 365, Google Workspace, Salesforce, Dropbox. Software accessed typically via a web browser.\"],\n        [\"What is a Public Cloud?\", \"Reveal\", \"Cloud infrastructure owned and operated by a third-party cloud provider, made available to the general public over the internet.\"],\n        [\"What is a Private Cloud?\", \"Reveal\", \"Cloud infrastructure operated solely for a single organization, whether managed internally or by a third party, and hosted either internally or externally.\"],\n        [\"What is a Hybrid Cloud?\", \"Reveal\", \"An environment that combines public and private clouds, allowing data and applications to be shared between them.\"],\n        [\"Name two of the three largest global public cloud providers.\", \"Reveal\", \"Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform (GCP).\"],\n        [\"List two significant benefits of using cloud computing.\", \"Reveal\", \"Examples: Cost savings (pay-as-you-go), Scalability/Elasticity, High Availability, Flexibility, Global reach, Faster deployment.\"],\n        [\"What fundamental technology enables much of cloud computing, particularly IaaS?\", \"Reveal\", \"Virtualization, which allows the creation of virtual machines (VMs) on physical hardware.\"],\n        [\"What are Containers (e.g., Docker) used for?\", \"Reveal\", \"Packaging an application and its dependencies together in an isolated environment, allowing it to run consistently across different computing environments.\"],\n        [\"What is the role of Container Orchestration tools like Kubernetes?\", \"Reveal\", \"To automate the deployment, scaling, management, and networking of containerized applications.\"],\n        [\"What is Serverless Computing (or FaaS - Function as a Service)?\", \"Reveal\", \"A cloud execution model where the cloud provider manages the server infrastructure, and developers only write and deploy code (functions) that run in response to events.\"],\n        [\"What does IAM stand for in a cloud context?\", \"Reveal\", \"Identity and Access Management.\"],\n        [\"What is the purpose of IAM services in the cloud?\", \"Reveal\", \"To securely manage user identities and control their access permissions to cloud resources.\"],\n        [\"What does High Availability (HA) mean in cloud architecture?\", \"Reveal\", \"Designing systems to minimize downtime and ensure continuous operation, often by using redundancy across multiple servers or data centers (Availability Zones).\"]\n    ],\n    \"Cybersecurity II\": [\n        [\"What is a Denial-of-Service (DoS) attack?\", \"Reveal\", \"An attack aimed at making a machine or network resource unavailable to its intended users by overwhelming it with traffic or requests.\"],\n        [\"What distinguishes a Distributed Denial-of-Service (DDoS) attack from a DoS attack?\", \"Reveal\", \"A DDoS attack uses multiple compromised computers (a botnet) to launch the attack, making it harder to block and more powerful.\"],\n        [\"What is a 'Man-in-the-Middle' (MitM) attack?\", \"Reveal\", \"An attack where the attacker secretly intercepts and potentially alters communications between two parties who believe they are communicating directly.\"],\n        [\"What is an 'SQL Injection' attack?\", \"Reveal\", \"A web security vulnerability where an attacker inserts malicious SQL statements into data entry fields to manipulate a backend database.\"],\n        [\"What is a 'Cross-Site Scripting' (XSS) attack?\", \"Reveal\", \"An attack where malicious scripts are injected into otherwise benign and trusted websites, which are then executed in the victim's browser when they visit the site.\"],\n        [\"What is 'Spear Phishing'?\", \"Reveal\", \"A highly targeted phishing attack aimed at a specific individual, group, or organization, often using personalized information to appear more credible.\"],\n        [\"What does MFA stand for, and why is it recommended?\", \"Reveal\", \"Multi-Factor Authentication. It's recommended because it requires two or more different verification methods (e.g., something you know, have, or are), providing significantly stronger security than passwords alone.\"],\n        [\"Give an example of each of the three common MFA factor types.\", \"Reveal\", \"Something you know (password, PIN), Something you have (smartphone app code, hardware token), Something you are (fingerprint, facial recognition).\"],\n        [\"What does RBAC stand for in access control?\", \"Reveal\", \"Role-Based Access Control. Access permissions are assigned based on defined roles within an organization, rather than directly to individual users.\"],\n        [\"What is the difference between an IDS and an IPS?\", \"Reveal\", \"An Intrusion Detection System (IDS) monitors network traffic for suspicious activity and alerts administrators. An Intrusion Prevention System (IPS) also monitors traffic but can automatically take action to block detected threats.\"],\n        [\"What does VPN stand for and what is its primary security benefit?\", \"Reveal\", \"Virtual Private Network. It creates a secure, encrypted tunnel over a public network (like the internet), protecting data confidentiality and masking the user's IP address.\"],\n        [\"What is 'Hashing' primarily used for in security?\", \"Reveal\", \"To create a unique, fixed-size string (hash) from input data for integrity verification (checking if data has changed) and secure password storage (storing hashes instead of plain text passwords).\"],\n        [\"How does hashing differ fundamentally from encryption?\", \"Reveal\", \"Hashing is a one-way process (you cannot easily recover the original data from the hash), while encryption is a two-way process (ciphertext can be decrypted back to plaintext with the correct key).\"],\n        [\"What is a 'Risk Assessment' in cybersecurity?\", \"Reveal\", \"The process of identifying potential security threats and vulnerabilities, analyzing the likelihood and potential impact of them occurring, and determining the overall risk level.\"],\n        [\"Name three key phases of an Incident Response plan.\", \"Reveal\", \"Examples: Preparation, Identification (Detection), Containment, Eradication, Recovery, Lessons Learned (Post-Incident Activity).\"],\n        [\"Why are formal Security Policies important for an organization?\", \"Reveal\", \"They establish clear rules, guidelines, and expectations for employees regarding the protection of information assets and acceptable use of systems.\"],\n        [\"What is the core principle behind the 'Zero Trust' security model?\", \"Reveal\", \"'Never trust, always verify.' It assumes that threats can exist both inside and outside the network, requiring strict verification for every user and device attempting to access resources.\"],\n        [\"What is 'Penetration Testing' (or Pen Testing)?\", \"Reveal\", \"An authorized, simulated cyberattack against a computer system or network to evaluate its security posture by identifying and exploiting vulnerabilities.\"]\n    ],\n    \"Data Science and Analytics\": [],\n    \"IT Support and Systems Admin\": [],\n    \"Database Admin\": []\n});",
        "Programming": "J:studyFramework(\"Programming\", {\n    \"HTML\": [],\n    \"CSS\": [],\n    \"JavaScript\": [],\n    \"CMD\": [],\n    \"PowerShell\": [],\n    \"Lua\": [],\n    \"Python\": [],\n    \"Java\": [],\n    \"Shell\": []\n});",
        "Languages": "J:studyFramework(\"Languages\", {\n    \"French\": []\n});",
        "Survival": "J:studyFramework(\"Survival\", {\n    \"Shelter I\": [],\n    \"Shelter II\": [],\n    \"Fire\": [],\n    \"Water\": [],\n    \"Food\": [],\n    \"Navigation I\": [],\n    \"Navigation II\": [],\n    \"Signaling and Communication\": [],\n    \"Foraging and Botany\": [],\n    \"Hunting and Tracking\": [],\n    \"Agriculture\": [],\n    \"Tool Making and Repair\": [],\n    \"Self-Defense and Security\": [],\n    \"Leadership\": []\n});"
    },
    "Files": {
        "Create Image": "J:const widthInput = prompt(\"Enter the desired width of the blank image in pixels:\");\nlet base64String = null;\n\nif (widthInput !== null) {\n    const width = parseInt(widthInput, 10);\n    if (!isNaN(width) && width > 0) {\n        const heightInput = prompt(\"Enter the desired height of the blank image in pixels:\");\n        if (heightInput !== null) {\n            const height = parseInt(heightInput, 10);\n            if (!isNaN(height) && height > 0) {\n                const canvas = document.createElement('canvas');\n                canvas.width = width;\n                canvas.height = height;\n                const ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                try {\n                    base64String = canvas.toDataURL();\n                    notes[\"Files\"][\"Custom Image\"] = {\n                        \"Preview\": \"J:previewFile();\",\n                        \"Rename\": \"J:renameFile();\",\n                        \"Edit\": \"J:editFile();\",\n                        \"Download\": \"J:downloadFile();\",\n                        \"Delete\": \"J:deleteFile();\",\n                        \"!Name\": \"CustomImage.png\",\n                        \"!Data\": base64String,\n                        \"!Type\": \"Image\",\n                        \"!Size\": \"Unknown\"\n                    };\n\n                    const tempUpload = notes[\"Files\"][\"Upload\"];\n                    const tempCustomImage = notes[\"Files\"][\"Create Image\"];\n                    const tempCustomSFX = notes[\"Files\"][\"Create SFX\"];\n                    delete notes[\"Files\"][\"Upload\"];\n                    delete notes[\"Files\"][\"Create Image\"];\n                    delete notes[\"Files\"][\"Create SFX\"];\n                    notes[\"Files\"][\"Create Image\"] = tempCustomImage;\n                    notes[\"Files\"][\"Create SFX\"] = tempCustomSFX;\n                    notes[\"Files\"][\"Upload\"] = tempUpload;\n                    showOption();\n\n                } catch (e) {\n                    console.error(\"Error generating Base64 string:\", e);\n                    alert(`Error generating image data. The requested dimensions (${width}x${height}) might be too large.`);\n                }\n            } else {\n                alert(\"Invalid height entered. Please enter a positive whole number.\");\n            }\n        } else {\n            alert(\"Operation cancelled by user.\");\n        }\n    } else {\n        alert(\"Invalid width entered. Please enter a positive whole number.\");\n    }\n} else {\n    alert(\"Operation cancelled by user.\");\n}\n\nif (base64String === null) {\n    console.log(\"Base64 string generation was cancelled or failed.\");\n}",
        "Create SFX": "J:optionsArea.innerHTML = \"\";\noutputArea.innerHTML = \"\";\n\nlet audioCtx;\ntry {\n    audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n} catch (e) {\n    console.error(\"Web Audio API is not supported in this browser\", e);\n    outputArea.innerHTML = \"<p style='color: #ff5555; text-align: center; font-weight: bold;'>Web Audio API is required for the SFX editor and is not supported by your browser.</p>\";\n    throw new Error(\"Web Audio API not supported.\");\n}\n\nconst NUM_STEPS = 32;\nconst MAX_FREQ = 5000;\nconst MAX_VOL = 1.0;\nconst DEFAULT_FREQ = 440;\nconst DEFAULT_VOL = 0.5;\nconst VOL_STEP = 0.1; // Define the volume step increment\n\nlet sfxParams = {\n    waveform: 'sine',\n    frequencySteps: Array(NUM_STEPS).fill(DEFAULT_FREQ),\n    volumeSteps: Array(NUM_STEPS).fill(DEFAULT_VOL),\n    duration: 0.5,\n};\n\nconst styles = {\n    container: `padding: 15px; font-family: sans-serif; display: flex; flex-direction: column; gap: 20px; height: calc(100% - 30px); overflow-y: auto; background-color: #282a36; color: #f8f8f2;`,\n    h3: `color: #50fa7b; margin-bottom: 10px; text-align: center;`,\n    controlsRow: `display: flex; gap: 25px; align-items: center; flex-wrap: wrap; justify-content: center; background-color: #44475a; padding: 15px; border-radius: 5px;`,\n    controlGroup: `display: flex; flex-direction: column; gap: 5px; align-items: flex-start;`,\n    label: `font-size: 0.9em; color: #bd93f9; margin-bottom: 3px;`,\n    select: `padding: 5px 8px; border: 1px solid #6272a4; background-color: #282a36; color: #f8f8f2; border-radius: 4px; min-width: 120px;`,\n    rangeInput: `cursor: pointer; padding: 0; border: 1px solid #6272a4; background-color: #282a36; border-radius: 4px; min-width: 120px; accent-color: #bd93f9;`,\n    valueSpan: `font-size: 0.85em; color: #f1fa8c; min-width: 60px; display: inline-block; text-align: right;`,\n    canvasEditorsContainer: `display: flex; gap: 20px; justify-content: space-around; margin-top: 15px; flex-wrap: wrap;`,\n    canvasEditor: `display: flex; flex-direction: column; align-items: center; gap: 8px; background-color: #44475a; padding: 10px; border-radius: 5px;`,\n    canvasLabel: `font-weight: bold; color: #8be9fd;`,\n    canvas: `border: 1px solid #6272a4; background-color: #282a36; cursor: crosshair; image-rendering: pixelated; width: 320px; height: 100px; display: block;`,\n    canvasHoverInfo: `font-size: 0.8em; min-height: 1em; color: #f8f8f2;`,\n    buttonsContainer: `display: flex; gap: 15px; justify-content: center; margin-top: 15px;`,\n    button: `padding: 10px 20px; background-color: #bd93f9; color: #282a36; font-weight: bold; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease;`,\n    infoText: `font-size: 0.85em; color: #f8f8f2; text-align: center; margin-top: 10px;`,\n    statusText: `font-size: 0.85em; color: #50fa7b; text-align: center; margin-top: 10px; min-height: 1.2em;`,\n};\n\noutputArea.innerHTML = `\n    <div style=\"${styles.container}\">\n        <h3 style=\"${styles.h3}\">SFX Creator</h3>\n        <div style=\"${styles.controlsRow}\">\n            <div style=\"${styles.controlGroup}\">\n                <label for=\"sfxWaveform\" style=\"${styles.label}\">Waveform:</label>\n                <select id=\"sfxWaveform\" style=\"${styles.select}\">\n                    <option value=\"sine\">Sine</option>\n                    <option value=\"square\">Square</option>\n                    <option value=\"sawtooth\">Sawtooth</option>\n                    <option value=\"triangle\">Triangle</option>\n                    <option value=\"noise\">Noise</option>\n                </select>\n            </div>\n            <div style=\"${styles.controlGroup}\">\n                <label for=\"sfxDuration\" style=\"${styles.label}\">Duration (s):</label>\n                <input type=\"range\" id=\"sfxDuration\" min=\"0.05\" max=\"4\" step=\"0.01\" value=\"${sfxParams.duration}\" style=\"${styles.rangeInput}\">\n                <span id=\"sfxDurationValue\" style=\"${styles.valueSpan}\">${sfxParams.duration.toFixed(2)}s</span>\n            </div>\n        </div>\n        <div style=\"${styles.canvasEditorsContainer}\">\n            <div style=\"${styles.canvasEditor}\">\n                <label for=\"freqCanvas\" style=\"${styles.canvasLabel}\">Frequency (Pitch)</label>\n                <canvas id=\"freqCanvas\" width=\"320\" height=\"100\" style=\"${styles.canvas}\"></canvas>\n                 <span id=\"freqHoverInfo\" style=\"${styles.canvasHoverInfo}\">&nbsp;</span>\n            </div>\n            <div style=\"${styles.canvasEditor}\">\n                <label for=\"volCanvas\" style=\"${styles.canvasLabel}\">Volume (0.1 steps)</label>\n                <canvas id=\"volCanvas\" width=\"320\" height=\"100\" style=\"${styles.canvas}\"></canvas>\n                <span id=\"volHoverInfo\" style=\"${styles.canvasHoverInfo}\">&nbsp;</span>\n            </div>\n        </div>\n        <div style=\"${styles.buttonsContainer}\">\n             <button id=\"playSfxButton\" style=\"${styles.button}\">Play Sound</button>\n        </div>\n        <p style=\"${styles.infoText}\">Click and drag on the graphs to edit steps. Saving creates a NEW '.wav' file in '${path.join('/') || '/'}'.</p>\n        <div id=\"saveStatus\" style=\"${styles.statusText}\"></div>\n    </div>\n`;\n\nconst waveformSelect = document.getElementById('sfxWaveform');\nconst durationSlider = document.getElementById('sfxDuration');\nconst durationValueSpan = document.getElementById('sfxDurationValue');\nconst playButton = document.getElementById('playSfxButton');\nconst saveStatus = document.getElementById('saveStatus');\nconst freqCanvas = document.getElementById('freqCanvas');\nconst volCanvas = document.getElementById('volCanvas');\nconst freqCtx = freqCanvas.getContext('2d');\nconst volCtx = volCanvas.getContext('2d');\nconst freqHoverInfo = document.getElementById('freqHoverInfo');\nconst volHoverInfo = document.getElementById('volHoverInfo');\n\nlet isDrawingFreq = false;\nlet isDrawingVol = false;\nconst barWidth = freqCanvas.width / NUM_STEPS;\nconst FREQ_COLOR = \"#ffb86c\";\nconst VOL_COLOR = \"#ff79c6\";\nconst DISABLED_COLOR = \"#6272a4\";\n\nfunction drawGraph(ctx, canvas, steps, maxVal, color, isDisabled = false, stepIncrement = null) {\n    const { width, height } = canvas;\n    ctx.fillStyle = '#282a36';\n    ctx.fillRect(0, 0, width, height);\n\n    for (let i = 0; i < NUM_STEPS; i++) {\n        const value = steps[i];\n        const barHeight = Math.max(1, (value / maxVal) * height);\n        const x = i * barWidth;\n        const y = height - barHeight;\n\n        ctx.fillStyle = isDisabled ? DISABLED_COLOR : color;\n        ctx.fillRect(x, y, barWidth - 1, barHeight);\n    }\n\n    if (canvas.id === 'freqCanvas') {\n        canvas.style.opacity = isDisabled ? '0.6' : '1';\n        canvas.style.cursor = isDisabled ? 'not-allowed' : 'crosshair';\n    }\n}\n\nfunction updateStepFromEvent(event, canvas, steps, maxVal, isFreqEditor) {\n    if (isFreqEditor && sfxParams.waveform === 'noise') return;\n\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    const stepIndex = Math.floor(x / barWidth);\n    let value = Math.max(0, Math.min(maxVal, (1 - (y / canvas.height)) * maxVal));\n\n    if (!isFreqEditor) {\n        value = Math.round(value / VOL_STEP) * VOL_STEP;\n    }\n\n    if (stepIndex >= 0 && stepIndex < NUM_STEPS) {\n        steps[stepIndex] = isFreqEditor ? Math.round(value) : parseFloat(value.toFixed(2)); // Store volume with precision\n        return { index: stepIndex, value: steps[stepIndex] };\n    }\n    return null;\n}\n\nfunction setupCanvasListeners(canvas, steps, maxVal, isDrawingFlagSetter, hoverInfoSpan, isFreqEditor) {\n    let isDrawing = false;\n\n    const redraw = () => {\n        const isDisabled = isFreqEditor && sfxParams.waveform === 'noise';\n        const color = isFreqEditor ? FREQ_COLOR : VOL_COLOR;\n        drawGraph(isFreqEditor ? freqCtx : volCtx, canvas, steps, maxVal, color, isDisabled, isFreqEditor ? null : VOL_STEP);\n    };\n\n    canvas.addEventListener('mousedown', (e) => {\n        if (isFreqEditor && sfxParams.waveform === 'noise') return;\n        isDrawing = true;\n        isDrawingFlagSetter(true);\n        const update = updateStepFromEvent(e, canvas, steps, maxVal, isFreqEditor);\n        if (update) redraw();\n    });\n\n    canvas.addEventListener('mousemove', (e) => {\n         const rect = canvas.getBoundingClientRect();\n         const x = e.clientX - rect.left;\n         const y = e.clientY - rect.top;\n         const stepIndex = Math.floor(x / barWidth);\n         let hoverValue = Math.max(0, Math.min(maxVal, (1 - (y / canvas.height)) * maxVal));\n\n         if (!isFreqEditor) {\n            hoverValue = Math.round(hoverValue / VOL_STEP) * VOL_STEP;\n         }\n\n         if (stepIndex >= 0 && stepIndex < NUM_STEPS) {\n              const displayValue = isFreqEditor ? `${Math.round(hoverValue)} Hz` : hoverValue.toFixed(1); // Display vol with 1 decimal place\n              hoverInfoSpan.style.color = '#f8f8f2';\n              hoverInfoSpan.textContent = `Step ${stepIndex + 1}: ~${displayValue}`;\n         } else {\n              hoverInfoSpan.textContent = '\\u00A0';\n         }\n\n\n        if (isDrawing) {\n            const update = updateStepFromEvent(e, canvas, steps, maxVal, isFreqEditor);\n            if (update) redraw();\n        }\n    });\n\n    canvas.addEventListener('mouseup', () => {\n        if (isDrawing) {\n            isDrawing = false;\n            isDrawingFlagSetter(false);\n        }\n    });\n\n    canvas.addEventListener('mouseleave', () => {\n         hoverInfoSpan.textContent = '\\u00A0';\n        if (isDrawing) {\n            isDrawing = false;\n            isDrawingFlagSetter(false);\n        }\n    });\n\n     redraw();\n     canvas.addEventListener('redraw', redraw);\n}\n\nwaveformSelect.value = sfxParams.waveform;\nwaveformSelect.addEventListener('change', (e) => {\n    sfxParams.waveform = e.target.value;\n    freqCanvas.dispatchEvent(new Event('redraw'));\n});\n\ndurationSlider.addEventListener('input', (e) => {\n    sfxParams.duration = parseFloat(e.target.value);\n    durationValueSpan.textContent = `${sfxParams.duration.toFixed(2)}s`;\n});\n\nsetupCanvasListeners(freqCanvas, sfxParams.frequencySteps, MAX_FREQ, (val) => isDrawingFreq = val, freqHoverInfo, true);\nsetupCanvasListeners(volCanvas, sfxParams.volumeSteps, MAX_VOL, (val) => isDrawingVol = val, volHoverInfo, false);\n\nplayButton.addEventListener('click', playSound);\n\nconst defaultButtonBg = '#bd93f9';\nconst hoverButtonBg = '#ff79c6';\nconst disabledButtonBg = '#6272a4';\n\nfunction applyButtonStyles(button) {\n    if (button.disabled) {\n        button.style.backgroundColor = disabledButtonBg;\n        button.style.cursor = 'not-allowed';\n    } else {\n        button.style.backgroundColor = defaultButtonBg;\n        button.style.cursor = 'pointer';\n    }\n}\n\napplyButtonStyles(playButton);\nplayButton.addEventListener('mouseover', () => {\n    if (!playButton.disabled) {\n        playButton.style.backgroundColor = hoverButtonBg;\n    }\n});\nplayButton.addEventListener('mouseout', () => {\n    applyButtonStyles(button);\n});\n\n\nlet currentSource = null;\n\nfunction playSound() {\n    if (!audioCtx || audioCtx.state === 'suspended') {\n       audioCtx.resume();\n    }\n    if (!audioCtx) return;\n\n    if (currentSource) {\n        try {\n            currentSource.stop();\n            if (currentSource.disconnect) currentSource.disconnect();\n        } catch (e) {}\n        currentSource = null;\n    }\n\n    const now = audioCtx.currentTime;\n    const duration = sfxParams.duration;\n\n    const gainNode = audioCtx.createGain();\n    gainNode.connect(audioCtx.destination);\n    gainNode.gain.setValueAtTime(sfxParams.volumeSteps[0] > 0 ? sfxParams.volumeSteps[0] : 0.0001, now);\n    const volCurve = new Float32Array(sfxParams.volumeSteps);\n    gainNode.gain.setValueCurveAtTime(volCurve, now, duration);\n\n    let sourceNode;\n    if (sfxParams.waveform === 'noise') {\n        const bufferSize = Math.ceil(audioCtx.sampleRate * duration);\n        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);\n        const output = noiseBuffer.getChannelData(0);\n        for (let i = 0; i < bufferSize; i++) {\n            output[i] = Math.random() * 2 - 1;\n        }\n        sourceNode = audioCtx.createBufferSource();\n        sourceNode.buffer = noiseBuffer;\n        sourceNode.loop = false;\n    } else {\n        sourceNode = audioCtx.createOscillator();\n        sourceNode.type = sfxParams.waveform;\n        sourceNode.frequency.setValueAtTime(sfxParams.frequencySteps[0], now);\n        const freqCurve = new Float32Array(sfxParams.frequencySteps);\n        sourceNode.frequency.setValueCurveAtTime(freqCurve, now, duration);\n    }\n\n    sourceNode.connect(gainNode);\n    sourceNode.start(now);\n    sourceNode.stop(now + duration);\n\n    currentSource = sourceNode;\n\n    sourceNode.onended = () => {\n        if (currentSource === sourceNode) {\n             currentSource = null;\n        }\n        try { sourceNode.disconnect(); } catch(e) {}\n        try { gainNode.disconnect(); } catch(e) {}\n    };\n     setTimeout(() => { try { gainNode.disconnect(); } catch(e) {} }, (duration + 0.1) * 1000);\n}\n\nasync function saveGeneratedSound() {\n    if (!audioCtx) {\n        alert(\"AudioContext not available. Cannot save.\");\n        return;\n    }\n    saveStatus.textContent = 'Rendering audio...';\n    saveStatus.style.color = '#50fa7b';\n    playButton.disabled = true;\n    applyButtonStyles(playButton);\n\n    try {\n        const duration = sfxParams.duration;\n        const sampleRate = audioCtx.sampleRate;\n        const offlineCtx = new OfflineAudioContext(1, Math.ceil(sampleRate * duration), sampleRate);\n\n        const gainNode = offlineCtx.createGain();\n        gainNode.connect(offlineCtx.destination);\n        gainNode.gain.setValueAtTime(sfxParams.volumeSteps[0] > 0 ? sfxParams.volumeSteps[0] : 0.0001, 0);\n        const volCurve = new Float32Array(sfxParams.volumeSteps);\n        gainNode.gain.setValueCurveAtTime(volCurve, 0, duration);\n\n        let sourceNode;\n        if (sfxParams.waveform === 'noise') {\n             const bufferSize = offlineCtx.length;\n             const noiseBuffer = offlineCtx.createBuffer(1, bufferSize, sampleRate);\n             const output = noiseBuffer.getChannelData(0);\n             for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;\n             sourceNode = offlineCtx.createBufferSource();\n             sourceNode.buffer = noiseBuffer;\n        } else {\n            sourceNode = offlineCtx.createOscillator();\n            sourceNode.type = sfxParams.waveform;\n            sourceNode.frequency.setValueAtTime(sfxParams.frequencySteps[0], 0);\n            const freqCurve = new Float32Array(sfxParams.frequencySteps);\n            sourceNode.frequency.setValueCurveAtTime(freqCurve, 0, duration);\n        }\n        sourceNode.connect(gainNode);\n        sourceNode.start(0);\n\n        const renderedBuffer = await offlineCtx.startRendering();\n\n        saveStatus.textContent = 'Encoding WAV...';\n        const wavDataUrl = await audioBufferToWavDataUrl(renderedBuffer);\n\n         let currentLevel = notes;\n         for (let i = 0; i < path.length; i++) {\n             if (currentLevel[path[i]] && typeof currentLevel[path[i]] === 'object') {\n                 currentLevel = currentLevel[path[i]];\n             } else {\n                 console.error(`Error finding parent directory. Path segment '${path[i]}' not found or not an object in path:`, path);\n                 throw new Error(`Could not find target directory at path: ${path.join('/')}`);\n             }\n          }\n         const baseName = \"New SFX\";\n         const extension = \".wav\";\n         let newFileName = baseName + extension;\n         let counter = 1;\n         while (currentLevel.hasOwnProperty(newFileName)) {\n             newFileName = `${baseName} (${counter})${extension}`;\n             counter++;\n             if (counter > 100) {\n                 throw new Error(\"Could not find a unique file name after 100 attempts.\");\n             }\n         }\n\n         currentLevel[newFileName] = {\n             \"Preview\": \"J:previewFile();\", \"Rename\": \"J:renameFile();\", \"Download\": \"J:downloadFile();\", \"Delete\": \"J:deleteFile();\",\n             \"!Name\": newFileName, \"!Data\": wavDataUrl, \"!Type\": \"Audio\", \"!Size\": \"Generated\"\n         };\n\n         const tempUpload = notes[\"Files\"][\"Upload\"];\n         const tempCustomImage = notes[\"Files\"][\"Create Image\"];\n         const tempCustomSFX = notes[\"Files\"][\"Create SFX\"];\n         delete notes[\"Files\"][\"Upload\"];\n         delete notes[\"Files\"][\"Create Image\"];\n         delete notes[\"Files\"][\"Create SFX\"];\n         if (tempCustomImage) notes[\"Files\"][\"Create Image\"] = tempCustomImage;\n         if (tempCustomSFX) notes[\"Files\"][\"Create SFX\"] = tempCustomSFX;\n         if (tempUpload) notes[\"Files\"][\"Upload\"] = tempUpload;\n\n         saveStatus.textContent = 'Saving data...';\n         saveData();\n         showOption();\n\n         alert(`Generated sound saved as: ${newFileName}`);\n         saveStatus.textContent = '';\n\n    } catch (error) {\n        console.error(\"Error saving generated sound:\", error);\n        alert(`Error saving sound: ${error.message || error}`);\n        saveStatus.textContent = `Error saving sound: ${error.message || 'Unknown error'}`;\n        saveStatus.style.color = '#ff5555';\n    } finally {\n         playButton.disabled = false;\n         applyButtonStyles(playButton);\n    }\n};\n\nasync function audioBufferToWavDataUrl(buffer) {\n    const wavBlob = generateWavBlob(buffer);\n    return await blobToDataURL(wavBlob);\n}\n\nfunction generateWavBlob(buffer) {\n    const numOfChan = buffer.numberOfChannels;\n    const bytesPerSample = 2;\n    const format = 1;\n    const sampleRate = buffer.sampleRate;\n    const blockAlign = numOfChan * bytesPerSample;\n    const byteRate = sampleRate * blockAlign;\n    const dataSize = buffer.length * numOfChan * bytesPerSample;\n    const bufferLength = 44 + dataSize;\n\n    const wavBuffer = new ArrayBuffer(bufferLength);\n    const view = new DataView(wavBuffer);\n\n    let pos = 0;\n\n    const writeString = (s) => { for (let i = 0; i < s.length; i++) view.setUint8(pos++, s.charCodeAt(i)); };\n    const writeUint16 = (d) => { view.setUint16(pos, d, true); pos += 2; };\n    const writeUint32 = (d) => { view.setUint32(pos, d, true); pos += 4; };\n\n    writeString('RIFF');\n    writeUint32(36 + dataSize);\n    writeString('WAVE');\n    writeString('fmt ');\n    writeUint32(16);\n    writeUint16(format);\n    writeUint16(numOfChan);\n    writeUint32(sampleRate);\n    writeUint32(byteRate);\n    writeUint16(blockAlign);\n    writeUint16(bytesPerSample * 8);\n    writeString('data');\n    writeUint32(dataSize);\n\n    const channels = [];\n    for (let i = 0; i < numOfChan; i++) {\n        channels.push(buffer.getChannelData(i));\n    }\n\n    for (let i = 0; i < buffer.length; i++) {\n        for (let chan = 0; chan < numOfChan; chan++) {\n            let sample = channels[chan][i];\n            sample = Math.max(-1, Math.min(1, sample));\n            sample = sample < 0 ? sample * 32768 : sample * 32767;\n            view.setInt16(pos, sample, true);\n            pos += bytesPerSample;\n        }\n    }\n\n    return new Blob([view], { type: 'audio/wav' });\n}\n\nfunction blobToDataURL(blob) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result);\n        reader.onerror = (e) => reject(new Error(`FileReader error: ${e.target.error}`));\n        reader.readAsDataURL(blob);\n    });\n}\n\nnewOptionButton(\"Save New SFX\", \"#393939\", saveGeneratedSound);",
        "Upload": "J:const input = document.createElement('input');\ninput.type = 'file';\n\ninput.onchange = function (event) {\n    const file = event.target.files[0];\n\n    if (!file) {\n        callback(null, 'No file selected.');\n        return;\n    }\n\n    const reader = new FileReader();\n\n    reader.onload = function (e) {\n        const base64String = e.target.result;\n        let fileType = 'Unknown';\n\n        if (file.type.startsWith('image/')) {\n            fileType = 'Image';\n        } else if (file.type.startsWith('audio/')) {\n            fileType = 'Audio';\n        } else if (file.type.startsWith('video/')) {\n            fileType = 'Video';\n        } else if (file.type === 'text/plain') {\n            fileType = 'Text';\n        } else if (file.type === 'text/html') {\n            fileType = 'HTML';\n        } else if (file.type === 'application/javascript' || file.type === 'text/javascript') {\n            fileType = 'JS';\n        }\n        if (file.type.startsWith('image/')) {\n            notes[\"Files\"][file.name] = {\n                \"Preview\": \"J:previewFile();\",\n                \"Rename\": \"J:renameFile();\",\n                \"Edit\": \"J:editFile();\",\n                \"Download\": \"J:downloadFile();\",\n                \"Delete\": \"J:deleteFile();\",\n                \"!Name\": file.name,\n                \"!Data\": base64String,\n                \"!Type\": fileType,\n                \"!Size\": file.size\n            };\n        } else {\n            notes[\"Files\"][file.name] = {\n                \"Preview\": \"J:previewFile();\",\n                \"Rename\": \"J:renameFile();\",\n                \"Download\": \"J:downloadFile();\",\n                \"Delete\": \"J:deleteFile();\",\n                \"!Name\": file.name,\n                \"!Data\": base64String,\n                \"!Type\": fileType,\n                \"!Size\": file.size\n            };\n        }\n        input.remove();\n        const tempUpload = notes[\"Files\"][\"Upload\"];\n        const tempCustomImage = notes[\"Files\"][\"Create Image\"];\n        const tempCustomSFX = notes[\"Files\"][\"Create SFX\"];\n        delete notes[\"Files\"][\"Upload\"];\n        delete notes[\"Files\"][\"Create Image\"];\n        delete notes[\"Files\"][\"Create SFX\"];\n        notes[\"Files\"][\"Create Image\"] = tempCustomImage;\n        notes[\"Files\"][\"Create SFX\"] = tempCustomSFX;\n        notes[\"Files\"][\"Upload\"] = tempUpload;\n        showOption();\n    };\n\n    reader.readAsDataURL(file);\n};\n\ninput.click();"
    },
    "Personal": {
        "Download": "J:outputArea.innerHTML = `<form id=\"loginForm\" style=\"margin: 10px; border: 5px solid black; width: calc(100% - 20px); min-height: calc(100% - 20px); padding: 20px; border-radius: 8px; background-color: white; font-size: 16px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: center;\" onsubmit=\"event.preventDefault(); login();\"><label for=\"username\" style=\"margin-bottom: 5px; font-weight: bold;\">Username:</label><input type=\"text\" id=\"username\" name=\"username\" required style=\"width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: inherit;\"><label for=\"password\" style=\"margin-bottom: 5px; font-weight: bold;\">Password:</label><input type=\"password\" id=\"password\" name=\"password\" required style=\"width: 100%; padding: 10px; margin-bottom: 20px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: inherit;\"><button type=\"submit\" style=\"padding: 12px 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: inherit; font-weight: bold; align-self: center;\">Download</button></form>`;\n\nwindow.login = function() {\n    const username = document.getElementById('username').value;\n    const password = document.getElementById('password').value;\n    download(username, password);\n}\n\nfunction download(username, password) {\n    fetch(`https://script.google.com/macros/s/AKfycbzIbsWBCRZ14jYrDarQGBBNxBV5TQz2kuNzBIFI1H9XkaScOa0ku9QAgNSds7YAv2777g/exec`, {\n        redirect: \"follow\",\n        method: 'POST',\n        body: JSON.stringify({ username : username , password : password , type : \"get\" }),\n        headers: {\n            'Content-Type': \"text/plain;charset=utf-8\"\n        }\n    })\n    .then(response => response.text())\n    .then(result => {\n        const newData = JSON.parse(result);\n        if (\"result\" in newData) {\n            notes[\"Personal\"] = {};\n            for (const key in newData.result) {\n                notes[\"Personal\"][key] = JSON.parse(newData.result[key])\n            }\n            saveData();\n        } else {\n            alert(newData.reply);\n        }\n        showOption();\n    });\n}\n"
    },
    "FullScreen": "J:if (document.documentElement.requestFullscreen) {\n    document.documentElement.requestFullscreen();\n} else if (document.documentElement.mozRequestFullScreen) { /* Firefox */\n    document.documentElement.mozRequestFullScreen();\n} else if (document.documentElement.webkitRequestFullscreen) { /* Chrome, Safari and Opera */\n    document.documentElement.webkitRequestFullscreen();\n} else if (document.documentElement.msRequestFullscreen) { /* IE/Edge */\n    document.documentElement.msRequestFullscreen();\n}\nshowOption();",
    "Dev": {
        "Toggle Edit Mode": "J:editMode = !editMode; showOption();",
        "Edit Notes": "J:editPath([]);",
        "Export": {
            "HTML": "J:function removeTextBetweenMarkersKeepMarkers(str, startMarker, endMarker, replacement) {\n    const startIndex = str.indexOf(startMarker);\n    const endIndex = str.indexOf(endMarker, startIndex + startMarker.length);\n    return str.slice(0, startIndex + startMarker.length) + replacement + str.slice(endIndex);\n}\nconst autoSave = notes[\"!Save\"];\nnotes[\"!Save\"] = false;\noptionsArea.innerHTML = \"\";\noutputArea.innerHTML = \"\";\nlet htmlContent = document.documentElement.outerHTML.split(\"//MARK\");\nconst last = htmlContent.pop();\nconst init = htmlContent.shift();\nlet newHTMLContent = init + \"//MARK\\nlet notes = \" + JSON.stringify(notes, null, 4) + \";\\n//MARK\" + last;\nnewHTMLContent = removeTextBetweenMarkersKeepMarkers(newHTMLContent, \"<!-- Default Styling -->\", \"</head>\", \"\\n\")\nconst blob = new Blob([newHTMLContent], {type: 'text/html'});\nconst a = document.createElement('a');\na.href = URL.createObjectURL(blob);\na.download = 'index.html';\na.click();\nURL.revokeObjectURL(a.href);\nnotes[\"!Save\"] = autoSave;\nshowOption();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "JSON": "J:const json = JSON.stringify(notes);\nconst blob = new Blob([json], { type: \"application/json\" });\nconst url = URL.createObjectURL(blob);\n\nconst a = document.createElement(\"a\");\na.href = url;\na.download = \"ToolKitSaveData.json\";\ndocument.body.appendChild(a);\na.click();\ndocument.body.removeChild(a);\nURL.revokeObjectURL(url);\nshowOption();",
            "Both": "J:function removeTextBetweenMarkersKeepMarkers(str, startMarker, endMarker, replacement) {\n    const startIndex = str.indexOf(startMarker);\n    const endIndex = str.indexOf(endMarker, startIndex + startMarker.length);\n    return str.slice(0, startIndex + startMarker.length) + replacement + str.slice(endIndex);\n}\nconst autoSave = notes[\"!Save\"];\nnotes[\"!Save\"] = false;\noptionsArea.innerHTML = \"\";\noutputArea.innerHTML = \"\";\nlet htmlContent = document.documentElement.outerHTML.split(\"//MARK\");\nconst last = htmlContent.pop();\nconst init = htmlContent.shift();\nlet newHTMLContent = init + \"//MARK\\nlet notes = \" + JSON.stringify(notes, null, 4) + \";\\n//MARK\" + last;\nnewHTMLContent = removeTextBetweenMarkersKeepMarkers(newHTMLContent, \"<!-- Default Styling -->\", \"</head>\", \"\\n\")\nconst blob = new Blob([newHTMLContent], {type: 'text/html'});\nconst a = document.createElement('a');\na.href = URL.createObjectURL(blob);\na.download = 'index.html';\na.click();\nURL.revokeObjectURL(a.href);\nnotes[\"!Save\"] = autoSave;\n\nconst json = JSON.stringify(notes);\nconst blob = new Blob([json], { type: \"application/json\" });\nconst url = URL.createObjectURL(blob);\n\nconst a = document.createElement(\"a\");\na.href = url;\na.download = \"ToolKitSaveData.json\";\ndocument.body.appendChild(a);\na.click();\ndocument.body.removeChild(a);\nURL.revokeObjectURL(url);\n\nshowOption();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        "Import": "J:const input = document.createElement('input');\ninput.type = 'file';\ninput.accept = 'application/json';\n\ninput.addEventListener('change', (event) => {\n    const file = event.target.files[0];\n    if (file) {\n        const reader = new FileReader();\n\n        reader.onload = (e) => {\n            try {\n                notes = JSON.parse(e.target.result);\n                input.remove()\n                path = [];\n                showOption();\n            } catch (error) {\n                alert('Invalid JSON file.');\n                document.body.removeChild(input);\n                showOption();\n            }\n        };\n\n        reader.readAsText(file);\n    } else {\n        input.remove() // remove input if no file was selected.\n    }\n});\n\ninput.click();",
        "Toggle Save": "J:notes[\"!Save\"] = !notes[\"!Save\"];\nsaveData();\nif (notes[\"!Save\"]) {\n    alert(\"Saving has been Enabled.\");\n} else {\n    alert(\"Saving has been Disabled.\");\n}\nshowOption();"
    },
    "!Functions": {
        "Start": "J:// S I T E  N A V I G A T I O N\n\nwindow.showOption = function(highlightButton = null) {\n    const currentOption = path.reduce((acc, key) => acc[key], notes);\n\n    optionsArea.innerHTML = \"\";\n    outputArea.innerHTML = \"\";\n    outputArea.style.height = \"auto\";\n\n    if (typeof currentOption === 'object' && currentOption !== null && !Array.isArray(currentOption)) {\n        Object.entries(currentOption).forEach(([optionName, optionValue], index) => {\n            if (optionName[0] !== '!' || editMode) {\n                let buttonColor = (index % 2 === 0) ? \"#393939\" : \"#262626\";\n                if (optionName === highlightButton) buttonColor = \"black\";\n\n                const optionButton = newOptionButton(optionName, buttonColor, () => {\n                    path.push(optionName);\n                    showOption();\n                });\n\n                if (editMode) {\n                    const editButton = document.createElement(\"button\");\n                    editButton.innerHTML = \"Edit\";\n                    editButton.style.marginLeft = \"5px\";\n                    editButton.style.width = \"60px\";\n                    editButton.style.color = \"white\";\n                    editButton.style.backgroundColor = buttonColor;\n                    editButton.style.fontSize = \"22px\";\n                    editButton.onclick = () => editPath([...path, optionName]);\n                    optionButton.parentNode.appendChild(editButton);\n                }\n            }\n        });\n        if (path.length > 0) {\n            newOptionButton(\"Return\",  (Object.entries(currentOption).length % 2 === 0) ? \"#393939\" : \"#262626\", () => {\n                path.pop();\n                showOption();\n            });\n        }\n    } else {\n        handleOptionValue(currentOption);\n        outputArea.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }\n};\n\nfunction handleOptionValue(option) {\n    if (option.startsWith('E:')) {\n        encrypt();\n    } else if (option.startsWith('J:')) {\n        path.pop();\n        try {\n            new Function(option.substring(2))();\n        } catch (e) {\n            console.error(\"Error running JavaScript:\", e);\n        }\n    } else if (option.startsWith('T:')) {\n        const chosenOption = path.pop();\n        showOption(chosenOption);\n        outputArea.innerHTML = `<div style=\"margin: 10px; border: 5px solid black; width: calc(100% - 40px); min-height: calc(100% - 40px); padding: 5px; border-radius: 8px; background-color: white; font-size: 20px;\">${option.substring(2)}</div>`;\n        MathJax.typeset();\n    } else {\n        path.pop();\n        showOption();\n    }\n}\n\nwindow.newOptionButton = function(name, color, click) {\n    const buttonArea = document.createElement(\"div\");\n    buttonArea.style.minHeight = \"60px\";\n    buttonArea.style.display = \"flex\";\n    optionsArea.appendChild(buttonArea);\n    const button = document.createElement(\"button\");\n    button.innerHTML = name;\n    button.style.color = \"white\";\n    button.style.backgroundColor = color;\n    button.style.minHeight = \"60px\";\n    button.style.width = \"100%\";\n    button.style.fontSize = \"22px\";\n    button.onclick = click;\n    buttonArea.appendChild(button);\n    return button;\n};\n\nwindow.editPath = function(p) {\n    const target = p.reduce((acc, part) => acc[part], notes);\n    const parent = p.slice(0, -1).reduce((acc, part) => acc[part], notes);\n    const lastKey = p.length > 0 ? p[p.length - 1] : null;\n\n    const isObj = typeof target === 'object' && target;\n    optionsArea.innerHTML = \"\";\n    outputArea.style.height = \"100%\";\n    outputArea.innerHTML = `<textarea id=\"ta\" wrap=\"off\" style=\"margin:10;border:5px solid black;width:calc(100% - 20px);min-height:calc(100% - 20px);padding:5;border-radius:8px;background-color:white;font-size:16px;\"></textarea>`;\n\n    const ta = document.getElementById(\"ta\");\n    ta.addEventListener('keydown', e => {\n        if (e.key === 'Tab') {\n        e.preventDefault();\n        const s = ta.selectionStart, en = ta.selectionEnd;\n        ta.value = ta.value.substring(0, s) + '    ' + ta.value.substring(en);\n        ta.selectionStart = ta.selectionEnd = s + 4;\n        }\n    });\n\n    const originalString = typeof target === 'string' ? target : null;\n    ta.value = isObj ? JSON.stringify(target, null, 4) : (typeof target === 'string' ? (target[1] === \":\" ? target.substring(2) : target) : JSON.stringify(target, null, 4));\n\n    const save = () => {\n        try {\n            const newValue = isObj ? JSON.parse(ta.value) : (originalString && originalString[1] === \":\" ? `${originalString[0]}:${ta.value}` : ta.value);\n            if (lastKey) {\n                parent[lastKey] = newValue;\n            } else {\n                notes = newValue;\n            }\n            saveData();\n            showOption();\n        } catch (e) {\n            alert(\"Invalid format.\");\n        }\n    };\n\n    newOptionButton(\"Save\", \"#393939\", save);\n};\n\nclass PRNG {\nconstructor(seed) {\n    this.seed = seed || Math.floor(Math.random() * 2 ** 32);\n    this.a = 1664525;\n    this.c = 1013904223;\n    this.m = 2 ** 32;\n    this.z = this.seed;\n}\nrandom() {\n    this.z = (this.a * this.z + this.c) % this.m;\n    return this.z / this.m;\n}\nrange(min, max) {\n    return min + (max - min) * this.random();\n}\nintRange(min, max) {\n    return Math.floor(this.range(min, max));\n}\nreset() {\n    this.z = this.seed;\n}\nnewSeed(newSeed) {\n    this.seed = newSeed;\n    this.z = newSeed;\n}\n}\n\nwindow.encrypt = function() {\n    window.myPRNG = new PRNG(0);\n    optionsArea.style.display = \"none\";\n    outputArea.style.height = \"100vh\";\n    outputArea.innerHTML = `<div style=\"position: relative; width: 150px; height: 250px; left: calc(50% - 85px); top: calc(50% - 135px); display: flex; flex-direction: column; gap: 10px; background-color: white; border-radius: 8px; border: 5px solid black; padding: 10px;\">\n        <input id=\"codeArea\" type=\"text\" placeholder=\"Code\" readonly style=\"height: 50px; font-size: 28px;\">\n        <div style=\"height: 40px; display: flex; gap: 10px;\">\n        <button onclick=\"changeCode('1');\" style=\"width: 100%; height: 40px; font-size: 28px;\">1</button>\n        <button onclick=\"changeCode('2');\" style=\"width: 100%; height: 40px; font-size: 28px;\">2</button>\n        <button onclick=\"changeCode('3');\" style=\"width: 100%; height: 40px; font-size: 28px;\">3</button>\n        </div>\n        <div style=\"height: 40px; display: flex; gap: 10px;\">\n        <button onclick=\"changeCode('4');\" style=\"width: 100%; height: 40px; font-size: 28px;\">4</button>\n        <button onclick=\"changeCode('5');\" style=\"width: 100%; height: 40px; font-size: 28px;\">5</button>\n        <button onclick=\"changeCode('6');\" style=\"width: 100%; height: 40px; font-size: 28px;\">6</button>\n        </div>\n        <div style=\"height: 40px; display: flex; gap: 10px;\">\n        <button onclick=\"changeCode('7');\" style=\"width: 100%; height: 40px; font-size: 28px;\">7</button>\n        <button onclick=\"changeCode('8');\" style=\"width: 100%; height: 40px; font-size: 28px;\">8</button>\n        <button onclick=\"changeCode('9');\" style=\"width: 100%; height: 40px; font-size: 28px;\">9</button>\n        </div>\n        <div style=\"height: 40px; display: flex; gap: 10px;\">\n        <button onclick=\"changeCode('<');\" style=\"width: 100%; height: 40px; font-size: 28px;\">&lt</button>\n        <button onclick=\"changeCode('0');\" style=\"width: 100%; height: 40px; font-size: 28px;\">0</button>\n        <button onclick=\"changeCode('>');\" style=\"width: 100%; height: 40px; font-size: 28px;\">&gt</button>\n        </div>\n    </div>`;\n    const codeArea = document.getElementById(\"codeArea\");\n    let code = \"\";\n    window.changeCode = function(char) {\n        if (char === \"<\") {\n            code = code.slice(0, -1);\n        } else if (char === \">\") {\n            if (code.length > 0) {\n                code = parseInt(code);\n                decrypt();\n            }\n        } else {\n            code += char;\n        }\n        codeArea.value = code;\n    };\n\n    function decrypt() {\n        const charAry = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \" \", \"!\", \"£\", \"%\", \"&\", \"^\", \"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \":\", \";\", \"#\", \"@\", \"?\", \",\", \".\", \"/\", \"_\", \"-\", \"+\", \"=\", \"¬\"];\n        const cypher = {};\n        myPRNG.newSeed(code);\n        if (code !== 0) {\n            for (let i = 0; i < 44; i++) {\n                const firstChr = charAry.splice(myPRNG.intRange(0, charAry.length), 1)[0];\n                const secondChr = charAry.splice(myPRNG.intRange(0, charAry.length), 1)[0];\n                cypher[firstChr] = secondChr;\n                cypher[secondChr] = firstChr;\n            }\n        } else {\n            charAry.forEach(char => cypher[char] = char);\n        }\n\n        function processText(inputText) {\n            return inputText.split(\"\").map(char => cypher[char] || (console.log(`Unsupported Character : ${char}`), \"\")).join(\"\");\n        }\n\n        const currentOption = path.reduce((acc, key) => acc[key], notes);\n        outputArea.innerHTML = `<textarea id=\"personalArea\" style=\"margin: 10; border: 5px solid black; width: calc(100% - 20px); min-height: calc(100vh - 80px); padding: 5; border-radius: 8px; background-color: white; font-size: 24px; \"></textarea><button onclick=\"savePersonal();\" style=\"margin: 0 10px 10px 10px; width: calc(100% - 20px); height: 50px; font-size: 32px; border: solid black 5px; border-radius: 8px;\">SAVE</button>`;\n        const personalArea = document.getElementById(\"personalArea\");\n        personalArea.value = processText(currentOption.substring(2)).replaceAll(\"¬\", \"\\n\");\n\n        window.savePersonal = function() {\n            const lastKey = path.pop();\n            const parent = path.reduce((acc, key) => acc[key], notes);\n            parent[lastKey] = \"E:\" + processText(personalArea.value.replaceAll(\"\\n\", \"¬\"));\n            optionsArea.style.display = \"flex\";\n            outputArea.style.height = \"auto\";\n            saveData();\n            showOption();\n        };\n    }\n};\n\n// R U N  O T H E R  F U N C T I O N S\nfunction runJSFunction(name) {\n    try{\n        new Function(notes[\"!Functions\"][name].substring(2))();\n    } catch(e) {\n        console.error(\"Error running function: \", e);\n    }\n}\n\nrunJSFunction(\"Game Framework\");\nrunJSFunction(\"Text Adventure\");\nrunJSFunction(\"Study Framework\");\nrunJSFunction(\"File Handling\");\n\n// S T A R T\nshowOption();",
        "Game Framework": "J:// G A M E   F R A M E W O R K\n\nwindow.gameFramework = function(gameObj) {\n    const screenRatio = innerWidth / innerHeight;\n    const canvasRatio = gameObj.width / gameObj.height;\n    let canvasWidth = (screenRatio > canvasRatio) ? `${Math.floor(canvasRatio * innerHeight)}px` : \"100%\";\n    let canvasHeight = (screenRatio > canvasRatio) ? \"100%\" : `${Math.floor((1/canvasRatio) * innerWidth)}px`;\n    let leftOffset = (screenRatio > canvasRatio) ? `${Math.floor((innerWidth - (canvasRatio * innerHeight))/2)}px` : \"0px\";\n    let topOffset = (screenRatio > canvasRatio) ? \"0px\" : `${Math.floor((innerHeight - ((1/canvasRatio) * innerWidth))/2)}px`;\n    customHTML.innerHTML = `<canvas id=\"canvas\" width=\"${gameObj.width}\" height=\"${gameObj.height}\" style=\"width:${canvasWidth}; height:${canvasHeight}; margin-left:${leftOffset}; margin-top:${topOffset}; image-rendering: pixelated;font-smooth: never; -webkit-font-smoothing : none;\"></canvas>`;\n    window.cnv = document.getElementById(\"canvas\");\n    window.ctx = cnv.getContext(\"2d\");\n    window.keys = { mouse: { x: 0, y: 0, clicked: false, held: false } };\n    window.currentLevel = 0;\n    ctx.imageSmoothingEnabled = false;\n    ctx.fillStyle = \"white\";\n    ctx.font = \"32px Rajdhani\";\n    ctx.fillText(\"LOADING\", cnv.width / 2 - 72, cnv.height / 2);\n\n    cnv.addEventListener('mousedown', (e) => {\n        const rect = cnv.getBoundingClientRect();\n        keys.mouse.x = (e.clientX - rect.left) * (cnv.width / rect.width);\n        keys.mouse.y = (e.clientY - rect.top) * (cnv.height / rect.height);\n        keys.mouse.clicked = true;\n        keys.mouse.held = true;\n    });\n\n    cnv.addEventListener('mouseup', () => {\n        keys.mouse.held = false;\n    });\n\n    cnv.addEventListener('mousemove', (e) => {\n        const rect = cnv.getBoundingClientRect();\n        keys.mouse.x = (e.clientX - rect.left) * (cnv.width / rect.width);\n        keys.mouse.y = (e.clientY - rect.top) * (cnv.height / rect.height);\n    });\n\n    cnv.addEventListener('touchstart', (e) => {\n        const touch = e.touches[0];\n        const rect = cnv.getBoundingClientRect();\n        keys.mouse.x = (touch.pageX - rect.left) * (cnv.width / rect.width);\n        keys.mouse.y = (touch.pageY - rect.top) * (cnv.height / rect.height);\n        keys.mouse.clicked = true;\n        keys.mouse.held = true;\n    });\n\n    cnv.addEventListener('touchend', () => {\n        keys.mouse.held = false;\n    });\n\n    cnv.addEventListener('touchmove', (e) => {\n        const touch = e.touches[0];\n        const rect = cnv.getBoundingClientRect();\n        keys.mouse.x = (touch.pageX - rect.left) * (cnv.width / rect.width);\n        keys.mouse.y = (touch.pageY - rect.top) * (cnv.height / rect.height);\n    });\n\n    window.addEventListener('keydown', (e) => {\n        keys[e.key] = { clicked: true, held: true };\n    });\n\n    window.addEventListener('keyup', (e) => {\n        if (keys[e.key]) {\n            keys[e.key].held = false;\n        }\n    });\n\n    function gamepadHandler(gamepad, connected) {\n        if (connected) {\n            console.log(\"Gamepad connected.\");\n        } else {\n            console.log(\"Gamepad disconnected.\");\n        }\n    }\n\n    window.addEventListener(\"gamepadconnected\", (e) => {\n        gamepadHandler(e.gamepad, true);\n    });\n\n    window.addEventListener(\"gamepaddisconnected\", (e) => {\n        gamepadHandler(e.gamepad, false);\n    });\n\n    function updateGamepads() {\n        const gamepads = navigator.getGamepads();\n        for (let i = 0; i < gamepads.length; i++) {\n            const gamepad = gamepads[i];\n            if (gamepad) {\n                gamepad.buttons.forEach((button, index) => {\n                    if (button.pressed) {\n                        if (!keys[i + \"-\" + index]) keys[i + \"-\" + index] = { clicked: false, held: false };\n                        if (!keys[i + \"-\" + index].held) keys[i + \"-\" + index].clicked = true;\n                        keys[i + \"-\" + index].held = true;\n                    } else {\n                        if (keys[i + \"-\" + index]) keys[i + \"-\" + index].held = false;\n                    }\n                });\n\n                if (gamepad.axes.length >= 2) {\n                    const leftStickX = gamepad.axes[0];\n                    const leftStickY = gamepad.axes[1];\n                    const deadzone = 0.5;\n                    const dpadLeftButtonIndex = 14;\n                    const dpadRightButtonIndex = 15;\n                    const dpadUpButtonIndex = 12;\n                    const dpadDownButtonIndex = 13;\n\n                    // Left stick as D-pad\n                    if (leftStickX < -deadzone) {\n                        keys[i + \"-\" + dpadLeftButtonIndex] = { held: true };\n                    } else if (!gamepad.buttons[dpadLeftButtonIndex].pressed) {\n                        keys[i + \"-\" + dpadLeftButtonIndex] = { held: false };\n                    }\n\n                    if (leftStickX > deadzone) {\n                        keys[i + \"-\" + dpadRightButtonIndex] = { held: true };\n                    } else if (!gamepad.buttons[dpadRightButtonIndex].pressed) {\n                        keys[i + \"-\" + dpadRightButtonIndex] = { held: false };\n                    }\n\n                    if (leftStickY < -deadzone) {\n                        keys[i + \"-\" + dpadUpButtonIndex] = { held: true };\n                    } else if (!gamepad.buttons[dpadUpButtonIndex].pressed) {\n                        keys[i + \"-\" + dpadUpButtonIndex] = { held: false };\n                    }\n\n                    if (leftStickY > deadzone) {\n                        keys[i + \"-\" + dpadDownButtonIndex] = { held: true };\n                    } else if (!gamepad.buttons[dpadDownButtonIndex].pressed) {\n                        keys[i + \"-\" + dpadDownButtonIndex] = { held: false };\n                    }\n                }\n            }\n            for (const keyInp in keys) {\n                if (keyInp.includes(\"-\") && keyInp != \"-\") {\n                    if (keys[keyInp].held) console.log(`Controller ${keyInp.split(\"-\")[0]} is holding Key ${keyInp.split(\"-\")[1]}`)\n                }\n            }\n        }\n        requestAnimationFrame(updateGamepads);\n    }\n    updateGamepads();\n\n    window.cls = function(colour) {\n        ctx.clearRect(0, 0, cnv.width, cnv.height);\n        if (colour) {\n            ctx.fillStyle = colour;\n            ctx.fillRect(0, 0, cnv.width, cnv.height);\n        }\n    };\n\n    window.spr = function(id, x, y, w, h, r) {\n        let img = gameObj.sprites[id];\n        let width = w === undefined ? img.width : Math.abs(w);\n        let height = h === undefined ? img.height : Math.abs(h);\n        let translateX = w < 0 ? x + width : x;\n        let translateY = h < 0 ? y + height : y;\n        let scaleX = w < 0 ? -1 : 1;\n        let scaleY = h < 0 ? -1 : 1;\n\n        ctx.save();\n        if (r) {\n            ctx.translate(x + width / 2, y + height / 2);\n            ctx.rotate(r * Math.PI / 180);\n            ctx.scale(scaleX, scaleY);\n            ctx.drawImage(img, -width / 2, -height / 2, width, height);\n        } else if (scaleX !== 1 || scaleY !== 1) {\n            ctx.translate(translateX, translateY);\n            ctx.scale(scaleX, scaleY);\n            ctx.drawImage(img, 0, 0, width, height);\n        } else {\n            ctx.drawImage(img, x, y, width, height);\n        }\n        ctx.restore();\n    };\n\n    window.ssh = function(id, x, y, w, h, r) {\n        let img = gameObj.spritesheet[id];\n        let width = w === undefined ? img.width : Math.abs(w);\n        let height = h === undefined ? img.height : Math.abs(h);\n        let translateX = w < 0 ? x + width : x;\n        let translateY = h < 0 ? y + height : y;\n        let scaleX = w < 0 ? -1 : 1;\n        let scaleY = h < 0 ? -1 : 1;\n\n        ctx.save();\n        if (r) {\n            ctx.translate(x + width / 2, y + height / 2);\n            ctx.rotate(r * Math.PI / 180);\n            ctx.scale(scaleX, scaleY);\n            ctx.drawImage(img, -width / 2, -height / 2, width, height);\n        } else if (scaleX !== 1 || scaleY !== 1) {\n            ctx.translate(translateX, translateY);\n            ctx.scale(scaleX, scaleY);\n            ctx.drawImage(img, 0, 0, width, height);\n        } else {\n            ctx.drawImage(img, x, y, width, height);\n        }\n        ctx.restore();\n    };\n\n    window.sfx = function(audioIndex, loop = false) {\n        if (!(\"audioBuffers\" in window) || !window.audioBuffers || !window.audioBuffers[audioIndex]) return null;\n        const audioContext = window.audioContexts[window.audioContextIndex];\n        const source = audioContext.createBufferSource();\n        source.buffer = window.audioBuffers[audioIndex];\n        source.connect(audioContext.destination);\n        source.loop = loop;\n        source.start();\n        window.audioContextIndex = (window.audioContextIndex + 1) % 4;\n        return source;\n    };\n\n    window.clk = function(id, pad = 0) {\n        if (typeof id === 'object' && id === keys.mouse) {\n            const clicked = keys.mouse.clicked;\n            keys.mouse.clicked = false;\n            return clicked;\n        }\n        if (typeof id === 'object' && id !== keys.mouse) {\n            const x = keys.mouse.x;\n            const y = keys.mouse.y;\n            const w = id.w;\n            const h = id.h;\n            if (x >= id.x && x <= id.x + w && y >= id.y && y <= id.y + h && keys.mouse.clicked) {\n                keys.mouse.clicked = false;\n                return true;\n            }\n            return false;\n        }\n        if (typeof id === 'number') {\n            const gamepadButtonId = `${pad}-${id}`;\n            if (keys[gamepadButtonId]) {\n                const clicked = keys[gamepadButtonId].clicked;\n                keys[gamepadButtonId].clicked = false;\n                return clicked;\n            }\n            return false;\n        }\n        if (keys[id]) {\n            const clicked = keys[id].clicked;\n            keys[id].clicked = false;\n            return clicked;\n        }\n        return false;\n    };\n\n    window.hld = function(id, pad = 0) {\n        if (typeof id === 'object' && id === keys.mouse) {\n            return keys.mouse.held;\n        }\n        if (typeof id === 'object' && id !== keys.mouse) {\n            const x = keys.mouse.x;\n            const y = keys.mouse.y;\n            const w = id.w;\n            const h = id.h;\n            return (x >= id.x && x <= id.x + w && y >= id.y && y <= id.y + h && keys.mouse.held);\n        }\n        if (typeof id === 'number') {\n            const gamepadButtonId = `${pad}-${id}`;\n            if (keys[gamepadButtonId]) {\n                return keys[gamepadButtonId].held;\n            }\n            return false;\n        }\n        if (keys[id]) {\n            return keys[id].held;\n        }\n        return false;\n    };\n\n    window.lvl = function(levelID) {\n        if (!(\"levels\" in gameObj)) return console.log(\"You have no Levels defined to run.\");\n        if (levelID >= gameObj.levels.length) return console.log(`Level ${levelID} does not exist.`);\n        currentLevel = levelID;\n        gameObj.levels[currentLevel].init();\n        let previousTimestamp = 0;\n        function updateLevel(currentTimestamp) {\n            if (currentLevel != levelID) return;\n            const deltaTime = (currentTimestamp - previousTimestamp) / 1000;\n            gameObj.levels[currentLevel].update(deltaTime);\n            previousTimestamp = currentTimestamp;\n            requestAnimationFrame(updateLevel);\n        }\n        requestAnimationFrame((timestamp) => {\n            previousTimestamp = timestamp;\n            updateLevel(timestamp);\n        });\n    };\n\n    function loadSprites() {\n        if (\"sprites\" in gameObj) {\n            let checkLoaded = 0;\n            gameObj.sprites.forEach((elem, index) => {\n                let img = new Image();\n                img.src = elem;\n                gameObj.sprites[index] = img;\n                img.onload = () => {\n                    checkLoaded += 1;\n                    if (checkLoaded == gameObj.sprites.length) loadSpriteSheet();\n                };\n            });\n        } else {\n            loadSpriteSheet();\n        }\n    }\n\n    function loadSpriteSheet() {\n        if (\"spritesheet\" in gameObj) {\n            let checkLoaded = 0;\n            const ssData = gameObj.spritesheet[0];\n            const ssWidth = gameObj.spritesheet[1];\n            const ssHeight = gameObj.spritesheet[2];\n            gameObj.spritesheet = [];\n            const img = new Image();\n            img.src = ssData;\n            img.onload = () => {\n                const spriteWidth = img.width / ssWidth;\n                const spriteHeight = img.height / ssHeight;\n                const sprites = [];\n                const tempCanvas = document.createElement('canvas');\n                const tempCtx = tempCanvas.getContext('2d');\n                tempCanvas.width = spriteWidth;\n                tempCanvas.height = spriteHeight;\n                for (let y = 0; y < ssHeight; y++) {\n                    for (let x = 0; x < ssWidth; x++) {\n                        tempCtx.clearRect(0, 0, spriteWidth, spriteHeight);\n                        tempCtx.drawImage(img, x * spriteWidth, y * spriteHeight, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);\n                        const spriteImg = new Image();\n                        spriteImg.src = tempCanvas.toDataURL();\n                        gameObj.spritesheet.push(spriteImg);\n                        spriteImg.onload = () => {\n                            checkLoaded += 1;\n                            if (checkLoaded === ssWidth * ssHeight) {\n                                loadAudio();\n                            }\n                        };\n                    }\n                }\n            };\n        } else {\n            loadAudio();\n        }\n    }\n\n    function loadAudio() {\n        if (\"audio\" in gameObj && gameObj.audio.length > 0) {\n            window.audioContexts = [new AudioContext(), new AudioContext(), new AudioContext(), new AudioContext()];\n            window.audioContextIndex = 0;\n            window.audioBuffers = [];\n            let audioLoaded = 0;\n\n            gameObj.audio.forEach((audioSrc, index) => {\n                fetch(audioSrc)\n                    .then(response => response.arrayBuffer())\n                    .then(arrayBuffer => window.audioContexts[0].decodeAudioData(arrayBuffer))\n                    .then(audioBuffer => {\n                        window.audioBuffers[index] = audioBuffer;\n                        audioLoaded++;\n                        if (audioLoaded === gameObj.audio.length) {\n                            lvl(0);\n                        }\n                    })\n                    .catch(error => {\n                        console.error(\"Error loading audio:\", error);\n                        audioLoaded++;\n                        if (audioLoaded === gameObj.audio.length) {\n                            lvl(0);\n                        }\n                    });\n            });\n        } else {\n            lvl(0);\n        }\n    }\n    loadSprites();\n}",
        "Text Adventure": "J:// T E X T   A D V E N T U R E\n\nwindow.textAdventure = function(novelTxt) {\n    optionsArea.style.display = \"none\";\n    window.sections = {};\n    window.textList = [];\n    window.vars = {};\n    window.currentSection = \"\";\n\n    const textOffset = countLeadingSpaces(novelTxt.split(\"\\n\")[1]);\n\n    function countLeadingSpaces(str) {\n        let count = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (str[i] === ' ') {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n\n    let currentSectionSearch = \"\";\n    let currentPassageSearch = \"\";\n    novelTxt.split(\"\\n\").forEach((elem) => {\n        elem = elem.substring(textOffset);\n        if (elem.includes(\"[[\") && elem.includes(\"]]:\")) {\n            currentSectionSearch = elem.split(\"[[\")[1].split(\"]]:\")[0];\n            sections[currentSectionSearch] = { \"text\": [], \"shown\": false, passages: {} };\n            currentPassageSearch = \"\";\n        } else {\n            if (currentSectionSearch == \"\") return;\n\n            if (elem.includes(\"[\") && elem.includes(\"]:\")) {\n                currentPassageSearch = elem.split(\"[\")[1].split(\"]:\")[0];\n                sections[currentSectionSearch].passages[currentPassageSearch] = { shown: false, text: [] };\n            } else if (currentPassageSearch != \"\") {\n                sections[currentSectionSearch].passages[currentPassageSearch].text.push(elem);\n            }\n            if (currentPassageSearch == \"\") sections[currentSectionSearch].text.push(elem);\n\n        }\n    });\n\n    outputArea.innerHTML = `<div id=\"novel\" style=\"margin: 10px; border: 5px solid black; width: calc(100% - 40px); min-height: calc(100% - 40px); padding: 5px; border-radius: 8px; background-color: white; font-size: 22px; white-space: pre-wrap;\"></div>`;\n    const novel = document.getElementById(\"novel\");\n\n\n    function addObject(sectionName, obj) {\n        obj.shown = true;\n        let sectionText = [];\n        obj.text.forEach((elem, index) => {\n            if (elem.startsWith(\"@JS\")) {\n                let customJS = new Function(elem.substring(4));\n                customJS();\n            } else if (elem.startsWith(\"@clear\")) {\n                textList = [];\n            } else if (elem.startsWith(\"@set\")) {\n                const setBroken = elem.split(\" \");\n                let output = (!isNaN(parseInt(setBroken[2]))) ? parseInt(setBroken[2]) : setBroken[2];\n                vars[setBroken[1]] = output;\n            } else if (elem.startsWith(\"@inc\")) {\n                const setBroken = elem.split(\" \");\n                let output = (!isNaN(parseInt(setBroken[2]))) ? parseInt(setBroken[2]) : setBroken[2];\n                vars[setBroken[1]] += output;\n            } else if (elem.startsWith(\"@dec\")) {\n                const setBroken = elem.split(\" \");\n                let output = (!isNaN(parseInt(setBroken[2]))) ? parseInt(setBroken[2]) : setBroken[2];\n                vars[setBroken[1]] -= output;\n            } else if (elem.startsWith(\"@prompt\")) {\n                const setBroken = elem.split(\" \");\n                setBroken.shift();\n                const varKey = setBroken.shift();\n                let promptValue = prompt(setBroken.join(\" \"));\n                let output = (!isNaN(parseInt(promptValue))) ? parseInt(promptValue) : promptValue;\n                vars[varKey] = output;\n            } else if (elem.startsWith(\"@show\")) {\n                const setBroken = elem.split(\" \");\n                setBroken.shift();\n                const sectionNameToShow = setBroken.join(\" \");\n                if (sectionNameToShow in sections) {\n                    sections[sectionNameToShow].shown = false;\n                    for (const passageName in sections[sectionNameToShow].passages) {\n                        sections[sectionNameToShow].passages[passageName].shown = false;\n                    }\n                }\n            } else {\n                sectionText.push(elem);\n            }\n        })\n        sectionText.push(\"<hr>\");\n        textList.push({section:sectionName, text:sectionText.join(\"<br>\")});\n        showTexts();\n    }\n\n    function checkConditions (checkAry) {\n        for (let i=1; i<checkAry.length; i++) {\n            if (checkAry[i].includes(\"<\")) {\n                if (vars[checkAry[i].split(\"<\")[0]] >= parseInt(checkAry[i].split(\"<\")[1])) return false;\n            } else if (checkAry[i].includes(\">\")) {\n                if (vars[checkAry[i].split(\">\")[0]] <= parseInt(checkAry[i].split(\">\")[1])) return false;\n            } else if (checkAry[i].includes(\"==\")) {\n                let output = (!isNaN(parseInt(checkAry[i].split(\"==\")[1]))) ? parseInt(checkAry[i].split(\"==\")[1]) : checkAry[i].split(\"==\")[1];\n                if (vars[checkAry[i].split(\"==\")[0]] != output) return false;\n            } else if (checkAry[i].includes(\"=\")) {\n                let output = (!isNaN(parseInt(checkAry[i].split(\"=\")[1]))) ? parseInt(checkAry[i].split(\"=\")[1]) : checkAry[i].split(\"=\")[1];\n                vars[checkAry[i].split(\"=\")[0]] = output;\n            }\n        }\n        return true;\n    }\n\n    window.showSection = function(sectionArray) {\n        let conditionsMet = checkConditions(sectionArray);\n        if (conditionsMet) {\n            currentSection = sectionArray[0];\n        } else {\n            sections[sectionArray[0]].shown = true;\n            currentSection = sectionArray.pop();\n        }\n        addObject(currentSection, sections[currentSection]);\n    }\n\n    window.showPassage = function(passageArray) {\n        let conditionsMet = checkConditions(passageArray);\n        if (conditionsMet) {\n            addObject(currentSection, sections[currentSection].passages[passageArray[0]]);\n        } else {\n            sections[currentSection].passages[passageArray[0]].shown = true;\n            addObject(currentSection, sections[currentSection].passages[passageArray.pop()]);\n        }\n        let count = 0;\n        for (const passageName in sections[currentSection].passages) {\n            if (sections[currentSection].passages[passageName].shown) count += 1;\n        }\n        for (const passageName in sections[currentSection].passages) {\n            if (passageName.startsWith(`@${count}`)) {\n                let newPassage = passageName.split(\" \");\n                newPassage.shift();\n                goTo(newPassage.join(\" \"));\n            }\n        }\n    }\n\n    window.goTo = function(destination) {\n        if (destination in sections[currentSection].passages) {\n            showPassage([destination]);\n        } else if (destination in sections) {\n            showSection([destination]);\n        }\n    }\n\n    function showTexts() {\n        let totalText = \"\";\n        for (let i=0; i<textList.length; i++) {\n\n            let brokenTxt = breakText(textList[i].text);\n\n            for (let j=0; j<brokenTxt.length; j++) {\n                if (brokenTxt[j].startsWith(\"[[\") && brokenTxt[j+1].startsWith(\"(\")) { // IF SECTION & ()\n                    let newSec = brokenTxt[j].slice(2, -2).split(\", \");\n                    brokenTxt[j] = (textList[i].section == currentSection && !sections[newSec[0]].shown) ? `<a style=\"cursor: pointer; color: blue; text-decoration: underline;\" onclick='showSection(${JSON.stringify(newSec)})'>${brokenTxt[j+1].slice(1, -1)}</a>` : brokenTxt[j+1].slice(1, -1);\n                    brokenTxt[j+1] = \"\";\n\n                } else if (brokenTxt[j].startsWith(\"[[\")) { // IF SECTION no ()\n                    let newSec = brokenTxt[j].slice(2, -2).split(\", \");\n                    brokenTxt[j] = (textList[i].section == currentSection && !sections[newSec[0]].shown) ? `<a style=\"cursor: pointer; color: blue; text-decoration: underline;\" onclick='showSection(${JSON.stringify(newSec)})'>${newSec[0]}</a>` : newSec[0];\n\n                } else if (brokenTxt[j].startsWith(\"[\") && brokenTxt[j+1].startsWith(\"(\")) { // IF PASSAGE & ()\n                    let newPass = brokenTxt[j].slice(1, -1).split(\", \");\n                    brokenTxt[j] = (textList[i].section == currentSection && !sections[currentSection].passages[newPass[0]].shown) ? `<a style=\"cursor: pointer; color: blue; text-decoration: underline;\" onclick='showPassage(${JSON.stringify(newPass)})'>${brokenTxt[j+1].slice(1, -1)}</a>` : brokenTxt[j+1].slice(1, -1);\n                    brokenTxt[j+1] = \"\";\n\n                } else if (brokenTxt[j].startsWith(\"[\")) { // IF PASSAGE no ()\n                    let newPass = brokenTxt[j].slice(1, -1).split(\", \");\n                    brokenTxt[j] = (textList[i].section == currentSection && !sections[currentSection].passages[newPass[0]].shown) ? `<a style=\"cursor: pointer; color: blue; text-decoration: underline;\" onclick='showPassage(${JSON.stringify(newPass)})'>${newPass[0]}</a>` : newPass[0];\n\n                } else if (brokenTxt[j].startsWith(\"{\")) {\n                    brokenTxt[j] = vars[brokenTxt[j].slice(1, -1)];\n                }\n            }\n            totalText += \"<br>\" + brokenTxt.join(\"\").replaceAll(\"&lsb\", \"[\").replaceAll(\"&rsb\", \"]\").replaceAll(\"&lcb\", \"{\").replaceAll(\"&rcb\", \"}\")\n        }\n        novel.innerHTML = \"<hr>\" + totalText;\n        outputArea.scrollIntoView({ behavior: 'smooth', block: 'end' });\n    }\n\n    function breakText(txt) {\n        let brokenTxt = [];\n        let brokenPlaceholder = \"\";\n        const pattern = /\\n@.*?\\n/gs;\n        txt = txt.replace(pattern, '')\n        \n        for (let i=0; i<txt.length; i++) {\n            let char = txt[i];\n            if (char == \"[\" && brokenPlaceholder != \"[\") {\n                brokenTxt.push(brokenPlaceholder);\n                brokenPlaceholder = \"[\"; \n            } else if (char == \"]\" && txt[i+1] != \"]\") {\n                brokenPlaceholder += char;\n                brokenTxt.push(brokenPlaceholder);\n                brokenPlaceholder = \"\";\n            } else if (char == \")\" && brokenPlaceholder.startsWith(\"(\")) {\n                brokenPlaceholder += char;\n                brokenTxt.push(brokenPlaceholder);\n                brokenPlaceholder = \"\";\n            } else if (i == txt.length-1) {\n                brokenPlaceholder += char;\n                brokenTxt.push(brokenPlaceholder);\n                brokenPlaceholder = \"\"; \n            } else if (char == \"{\") {\n                brokenTxt.push(brokenPlaceholder);\n                brokenPlaceholder = \"{\";\n            } else if (char == \"}\") {\n                brokenPlaceholder += char;\n                brokenTxt.push(brokenPlaceholder);\n                brokenPlaceholder = \"\";\n            } else {\n                brokenPlaceholder += char;\n            }\n        }\n        return brokenTxt\n    }\n\n    showSection([Object.keys(sections)[0]])\n}",
        "Study Framework": "J:window.studyFramework = function(topicTitle, topicObject) {\n    showOption();\n    // --- Study Data and Core Elements (scoped to the framework instance) ---\n    let studyArea = null;\n    let questionTextEl = null;\n    let answerButtonsEl = null;\n    let navigationEl = null;\n    let scoreOverlayEl = null;\n\n    window.studyData = { // Use window scope if other parts of your app need access, otherwise keep it local\n        originalQuestions: [],\n        questions: [],\n        currentIndex: 0,\n        correctCount: 0,\n        incorrectCount: 0,\n        config: {\n            looping: false,\n            randomOrder: false\n        }\n    };\n\n    // --- Helper Functions ---\n    function shuffleArray(array) {\n        let currentIndex = array.length, randomIndex;\n        const newArray = [...array]; // Create a copy to avoid modifying the original\n        while (currentIndex !== 0) {\n            randomIndex = Math.floor(Math.random() * currentIndex);\n            currentIndex--;\n            [newArray[currentIndex], newArray[randomIndex]] = [\n                newArray[randomIndex], newArray[currentIndex]];\n        }\n        return newArray;\n    }\n\n    // --- UI Update Functions ---\n    function updateScoreOverlay() {\n        if (scoreOverlayEl) {\n            if (window.studyData.config.looping) {\n                scoreOverlayEl.innerHTML = `Correct: ${window.studyData.correctCount} | Incorrect: ${window.studyData.incorrectCount}`;\n                scoreOverlayEl.style.display = 'block';\n            } else {\n                scoreOverlayEl.style.display = 'none'; // Hide if not looping\n            }\n        }\n    }\n\n    function showFinalScore() {\n        if (!studyArea) return; // Safety check\n        const totalAttempts = window.studyData.correctCount + window.studyData.incorrectCount;\n        const scorePercent = totalAttempts > 0\n            ? ((window.studyData.correctCount / totalAttempts) * 100).toFixed(1)\n            : 0;\n        studyArea.innerHTML = `<div style=\"font-size: 24px; font-weight: bold; text-align: center; margin-top: 30px;\">Study Session Finished!<br><br>Correct Answers: ${window.studyData.correctCount}<br>Incorrect Clicks: ${window.studyData.incorrectCount}<br>(${scorePercent}% Accuracy on clicks)<br><br></div>`;\n        // Add a button to go back to topic selection\n        const backButton = document.createElement('button');\n        backButton.textContent = 'Study Again (Select Topics)';\n        backButton.style.cssText = \"padding: 12px 20px; font-size: 16px; cursor: pointer; border: 1px solid #ccc; background-color: #f8f9fa; border-radius: 5px; margin-top: 20px;\";\n        backButton.onclick = () => showTopicSelection(); // Re-show the initial screen\n        studyArea.appendChild(backButton);\n\n        if (scoreOverlayEl) scoreOverlayEl.style.display = 'none'; // Hide score overlay on final screen\n    }\n\n    // --- Event Handling ---\n    function handleAnswerClick(isCorrect, buttonElement) {\n        buttonElement.disabled = true;\n        buttonElement.style.opacity = '0.7';\n        buttonElement.style.cursor = 'default';\n        buttonElement.style.boxShadow = 'none';\n\n        if (isCorrect) {\n            window.studyData.correctCount++;\n            const buttons = answerButtonsEl.querySelectorAll('button');\n            buttons.forEach(btn => {\n                btn.disabled = true; // Disable all buttons\n                btn.style.cursor = 'default';\n                btn.style.boxShadow = 'none';\n                if (btn === buttonElement) { // Highlight correct\n                    btn.style.backgroundColor = '#d4edda';\n                    btn.style.borderColor = '#c3e6cb';\n                    btn.style.opacity = '1';\n                } else { // Dim others\n                    btn.style.opacity = '0.6';\n                }\n            });\n\n            // Show feedback text\n            const currentQuestionData = window.studyData.questions[window.studyData.currentIndex];\n            const feedbackText = currentQuestionData[currentQuestionData.length - 1];\n            console.log(feedbackText)\n            questionTextEl.innerHTML = feedbackText;\n            MathJax.typeset();\n            questionTextEl.style.fontStyle = 'italic';\n            questionTextEl.style.fontWeight = 'bold';\n\n            answerButtonsEl.style.display = 'none'; // Hide answer buttons\n            navigationEl.innerHTML = ''; // Clear previous nav buttons (if any)\n\n            // Add Continue button\n            const nextButton = document.createElement('button');\n            nextButton.textContent = 'Continue';\n            nextButton.style.cssText = \"padding: 12px 20px; font-size: 16px; cursor: pointer; border: 1px solid #ccc; background-color: #f8f9fa; border-radius: 5px; transition: background-color 0.2s, border-color 0.2s; width: 100%; max-width: 200px; box-sizing: border-box; margin-top: 20px;\";\n            nextButton.onmouseover = () => { nextButton.style.backgroundColor = '#e2e6ea'; nextButton.style.borderColor = '#adb5bd'; };\n            nextButton.onmouseout = () => { nextButton.style.backgroundColor = '#f8f9fa'; nextButton.style.borderColor = '#ccc'; };\n            nextButton.onclick = () => studyFramework_nextQuestion(); // Use the global function\n            navigationEl.appendChild(nextButton);\n            navigationEl.style.display = 'flex'; // Ensure navigation is visible\n            navigationEl.style.justifyContent = 'center';\n            navigationEl.style.width = '100%';\n\n\n        } else {\n            window.studyData.incorrectCount++;\n            buttonElement.style.backgroundColor = '#f8d7da'; // Red background for incorrect\n            buttonElement.style.borderColor = '#f5c6cb';\n            buttonElement.style.borderWidth = '2px';\n\n            // Shake animation\n            buttonElement.style.transition = 'transform 0.1s ease-in-out';\n            buttonElement.animate([\n                { transform: 'translateX(-5px)' },\n                { transform: 'translateX(5px)' },\n                { transform: 'translateX(-5px)' },\n                { transform: 'translateX(0)' }\n            ], { duration: 300, easing: 'ease-in-out' });\n        }\n        updateScoreOverlay(); // Update score after every click\n    }\n\n    // --- Question Display Logic ---\n    function showQuestion() {\n        if (window.studyData.currentIndex >= window.studyData.questions.length) {\n            if (window.studyData.config.looping) {\n                window.studyData.currentIndex = 0; // Reset index\n                if (window.studyData.config.randomOrder) {\n                    // Reshuffle original selected questions for the new loop\n                    window.studyData.questions = shuffleArray(window.studyData.originalQuestions);\n                } else {\n                    // If not random, just reuse the original order (already in window.studyData.originalQuestions)\n                    window.studyData.questions = [...window.studyData.originalQuestions];\n                }\n                // Continue to display the first question of the new loop below\n            } else {\n                showFinalScore(); // End of non-looping session\n                return; // Stop execution here\n            }\n        }\n\n        // Ensure elements exist (could happen if called before structure is ready)\n        if (!questionTextEl || !answerButtonsEl || !navigationEl) {\n             console.error(\"Study elements not initialized correctly.\");\n             // Attempt to re-initialize? Or show error. For now, log and return.\n             if (studyArea) initializeInnerStructure(studyArea); // Try re-initializing structure\n             else return; // Cannot proceed\n        }\n\n        const currentQuestionData = window.studyData.questions[window.studyData.currentIndex];\n        if (!currentQuestionData || currentQuestionData.length < 3) {\n            console.error(\"Invalid question data format at index:\", window.studyData.currentIndex, currentQuestionData);\n            // Optionally skip this question or show an error\n            studyFramework_nextQuestion(); // Skip to next\n            return;\n        }\n        const question = currentQuestionData[0];\n        const correctAnswer = currentQuestionData[1];\n        const incorrectAnswers = currentQuestionData.slice(2, -1); // Exclude question, correct answer, and feedback\n\n        // Reset question display\n        questionTextEl.innerHTML = question;\n        MathJax.typeset();\n        questionTextEl.style.fontSize = '22px';\n        questionTextEl.style.fontWeight = 'normal';\n        questionTextEl.style.marginBottom = '30px';\n        questionTextEl.style.textAlign = 'center';\n        questionTextEl.style.width = '100%';\n        questionTextEl.style.fontStyle = 'normal'; // Reset style\n\n        // Reset and repopulate answer buttons\n        answerButtonsEl.innerHTML = '';\n        answerButtonsEl.style.display = 'grid'; // Use grid for layout\n        answerButtonsEl.style.gap = '10px';\n        answerButtonsEl.style.width = '100%';\n        answerButtonsEl.style.maxWidth = '600px'; // Limit width for better layout\n        answerButtonsEl.style.marginTop = '0';\n        answerButtonsEl.style.marginBottom = '20px';\n\n\n        const allAnswers = [correctAnswer, ...incorrectAnswers];\n        const shuffledAnswers = shuffleArray(allAnswers); // Shuffle answers each time\n\n        // Adjust grid columns based on number of answers\n        if (incorrectAnswers.length > 0) { // More than one option (MCQ)\n             answerButtonsEl.style.gridTemplateColumns = 'repeat(auto-fit, minmax(150px, 1fr))';\n        } else { // Only one option (Flashcard style)\n             answerButtonsEl.style.gridTemplateColumns = '1fr'; // Single column\n             answerButtonsEl.style.maxWidth = '300px'; // Narrower for single button\n        }\n\n        shuffledAnswers.forEach(answerText => {\n            const button = document.createElement('button');\n            button.textContent = answerText;\n            // Basic styling - apply consistent styles\n            button.style.cssText = \"padding: 12px 20px; font-size: 16px; cursor: pointer; border: 1px solid #ccc; background-color: #e7e7e7; border-radius: 5px; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s, opacity 0.2s; width: 100%; box-sizing: border-box; text-align: center;\";\n             // Hover effect\n            button.onmouseover = () => { if (!button.disabled) { button.style.backgroundColor = '#ddd'; button.style.borderColor = '#bbb'; button.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)'; } };\n            button.onmouseout = () => { if (!button.disabled) { button.style.backgroundColor = '#e7e7e7'; button.style.borderColor = '#ccc'; button.style.boxShadow = 'none'; } };\n\n            const isCorrect = (answerText === correctAnswer);\n            button.onclick = () => handleAnswerClick(isCorrect, button); // Attach click handler\n            answerButtonsEl.appendChild(button);\n        });\n\n        // Hide navigation until an answer is selected\n        navigationEl.style.display = 'none';\n        navigationEl.innerHTML = '';\n\n        updateScoreOverlay(); // Ensure score overlay is correct\n    }\n\n    // --- Navigation Function (make it globally accessible if needed) ---\n    window.studyFramework_nextQuestion = function() {\n        window.studyData.currentIndex++;\n        showQuestion(); // Show the next question\n    };\n\n    // --- Initialization Functions ---\n\n    // Sets up the divs *inside* the studyArea for question/answers/nav\n    function initializeInnerStructure(targetArea) {\n        targetArea.innerHTML = `\n            <div id=\"questionTextInternal\" style=\"width: 100%;\"></div>\n            <div id=\"answerButtonsInternal\" style=\"width: 100%;\"></div>\n            <div id=\"navigationInternal\" style=\"width: 100%; margin-top: auto; display: flex; justify-content: center;\"></div>\n            <div id=\"scoreOverlayInternal\"></div>\n        `;\n        targetArea.style.display = 'flex';\n        targetArea.style.flexDirection = 'column';\n        targetArea.style.alignItems = 'center';\n        targetArea.style.padding = '20px';\n        targetArea.style.boxSizing = 'border-box';\n        // Ensure position relative for overlay positioning\n        if (!targetArea.style.position || targetArea.style.position === 'static') {\n            targetArea.style.position = 'relative';\n        }\n\n        // Assign elements to the module-scoped variables\n        questionTextEl = document.getElementById(\"questionTextInternal\");\n        answerButtonsEl = document.getElementById(\"answerButtonsInternal\");\n        navigationEl = document.getElementById(\"navigationInternal\");\n        scoreOverlayEl = document.getElementById(\"scoreOverlayInternal\");\n\n        // Style the score overlay\n        if (scoreOverlayEl) {\n            scoreOverlayEl.style.cssText = \"position: absolute; bottom: 10px; right: 10px; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 8px 12px; border-radius: 5px; font-size: 14px; z-index: 10; display: none;\"; // Initially hidden\n        }\n    }\n\n    // Starts the actual study session with selected questions and config\n    function startStudySession(selectedQuestions, config) {\n        // Configure study data\n        window.studyData.originalQuestions = [...selectedQuestions]; // Store the combined list\n        window.studyData.config = config; // Store looping/random options\n\n        // Prepare the initial question list based on randomOrder config\n        if (config.randomOrder) {\n            window.studyData.questions = shuffleArray(window.studyData.originalQuestions);\n        } else {\n            window.studyData.questions = [...window.studyData.originalQuestions];\n        }\n\n        // Reset progress\n        window.studyData.currentIndex = 0;\n        window.studyData.correctCount = 0;\n        window.studyData.incorrectCount = 0;\n\n        // Setup the main study area UI\n        outputArea.innerHTML = `<div id=\"studyArea\" style=\"margin: 10px; border: 5px solid black; width: calc(100% - 20px); min-height: 300px; padding: 5px; border-radius: 8px; background-color: white; font-size: 22px; position: relative; display: flex; flex-direction: column; align-items: center;\">Loading...</div>`;\n        studyArea = document.getElementById(\"studyArea\"); // Get the newly created study area\n\n        if (!studyArea) {\n            console.error(\"Failed to create studyArea element.\");\n            outputArea.innerHTML = \"<p style='color: red;'>Error: Could not initialize study area.</p>\";\n            return;\n        }\n\n        // Initialize the inner structure (question/answer/nav divs)\n        initializeInnerStructure(studyArea);\n\n        // Show the first question\n        showQuestion();\n    }\n\n    function showTopicSelection() {\n        let topicCheckboxesHTML = '<h3 style=\"margin-top: 0; margin-bottom: 15px;\">Select Topics:</h3>'; // Adjusted margins for h3\n        const topicNames = Object.keys(topicObject);\n\n        // Handle case where no topics are provided\n        if (topicNames.length === 0) {\n             // Use studyArea styling for the error message container too\n             outputArea.innerHTML = `\n                <div style=\"margin: 10px; border: 5px solid black; width: calc(100% - 20px); max-width: 800px; min-height: 150px; padding: 20px; border-radius: 8px; background-color: white; font-size: 22px; position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; box-shadow: 0 4px 8px rgba(0,0,0,0.1); box-sizing: border-box;\">\n                    <p style='color: orange; text-align: center; margin: 0;'>No study topics have been defined.</p>\n                </div>`;\n             return;\n        }\n\n        // Create checkboxes for each topic\n        topicNames.forEach((topicName, index) => {\n            // Create a reasonably safe ID from the topic name\n             const safeId = `topic_${index}_${topicName.replace(/[^a-zA-Z0-9_-]/g, '')}`;\n            topicCheckboxesHTML += `\n                <div style=\"margin-bottom: 10px;\">\n                    <input type=\"checkbox\" id=\"${safeId}\" name=\"topic\" value=\"${topicName}\" style=\"margin-right: 8px; vertical-align: middle; transform: scale(1.1);\">\n                    <label for=\"${safeId}\" style=\"vertical-align: middle; cursor: pointer;\">${topicName}</label>\n                </div>\n            `;\n        });\n\n        // Create checkboxes for study options\n        let optionsHTML = `\n            <h3 style=\"margin-top: 20px; margin-bottom: 15px;\">Options:</h3>\n            <div style=\"margin-bottom: 10px;\">\n                <input type=\"checkbox\" id=\"option_looping\" name=\"looping\" style=\"margin-right: 8px; vertical-align: middle; transform: scale(1.1);\">\n                <label for=\"option_looping\" style=\"vertical-align: middle; cursor: pointer;\">Looping (Restart questions when finished)</label>\n            </div>\n            <div>\n                <input type=\"checkbox\" id=\"option_randomOrder\" name=\"randomOrder\" style=\"margin-right: 8px; vertical-align: middle; transform: scale(1.1);\">\n                <label for=\"option_randomOrder\" style=\"vertical-align: middle; cursor: pointer;\">Random Order (Shuffle questions)</label>\n            </div>\n        `;\n\n        // Create the \"Start Study\" button\n        let startButtonHTML = `<button id=\"startStudyButton\" style=\"margin-top: 25px; padding: 12px 25px; font-size: 18px; cursor: pointer; background-color: #28a745; color: white; border: none; border-radius: 5px; transition: background-color 0.2s; font-weight: bold;\">Start Study Session</button>`;\n\n        // Assemble the selection screen HTML\n        outputArea.innerHTML = `\n            <div style=\"margin: 10px; border: 5px solid black; width: calc(100% - 20px); min-height: calc(100% - 20px); padding: 20px; border-radius: 8px; background-color: white; font-size: 18px; position: relative; display: flex; flex-direction: column; box-shadow: 0 4px 8px rgba(0,0,0,0.1); box-sizing: border-box;\">\n                <h1><b><u>${topicTitle}</u></b></h1>\n                ${topicCheckboxesHTML}\n                <hr style=\"margin: 20px 0; border: 0; border-top: 1px solid #ddd;\">\n                ${optionsHTML}\n                <hr style=\"margin: 20px 0; border: 0; border-top: 1px solid #ddd;\">\n                <div style=\"text-align: center; margin-top: auto; padding-top: 10px;\"> ${startButtonHTML}\n                </div>\n            </div>\n        `;\n\n        // Add event listener to the start button (logic remains the same)\n        const startButton = document.getElementById('startStudyButton');\n        if (startButton) {\n             // Add hover effect for button\n             startButton.onmouseover = () => startButton.style.backgroundColor = '#218838'; // Darker green on hover\n             startButton.onmouseout = () => startButton.style.backgroundColor = '#28a745';  // Original green\n\n             // Define action on click\n             startButton.addEventListener('click', () => {\n                // Find all checked topic checkboxes\n                const selectedTopics = [];\n                document.querySelectorAll('input[name=\"topic\"]:checked').forEach(checkbox => {\n                    selectedTopics.push(checkbox.value);\n                });\n\n                // Validate that at least one topic was selected\n                if (selectedTopics.length === 0) {\n                    alert(\"Please select at least one topic to study.\");\n                    return; // Stop if no topics are chosen\n                }\n\n                // Combine questions from the selected topics\n                let combinedQuestions = [];\n                selectedTopics.forEach(topicName => {\n                    // Check if the topic exists and its value is an array\n                    if (topicObject[topicName] && Array.isArray(topicObject[topicName])) {\n                         combinedQuestions = combinedQuestions.concat(topicObject[topicName]);\n                    } else {\n                        console.warn(`Topic \"${topicName}\" selected but not found or is not an array in the provided topicObject.`);\n                    }\n                });\n\n                 // Validate that questions were actually found\n                 if (combinedQuestions.length === 0) {\n                    alert(\"No valid questions were found for the selected topic(s). Please check the topic data.\");\n                    return; // Stop if selection resulted in zero questions\n                 }\n\n                // Get config options from the option checkboxes\n                const config = {\n                    looping: document.getElementById('option_looping').checked,\n                    randomOrder: document.getElementById('option_randomOrder').checked\n                };\n\n                // Start the study session with the gathered questions and config\n                startStudySession(combinedQuestions, config);\n            });\n        } else {\n            console.error(\"Could not find the #startStudyButton element to attach event listener.\");\n        }\n    }\n\n    // --- Initial Execution ---\n    // Show the topic selection screen when the framework is called\n    showTopicSelection();\n\n};\n\n",
        "File Handling": "J:// F I L E   H A N D L I N G\n\nwindow.previewFile = function() {\n    showOption();\n    const file = notes[\"Files\"][path[path.length - 1]];\n    const fileType = file[\"!Type\"];\n    if (fileType == \"Image\") {\n        outputArea.innerHTML = `<img src=\"${file[\"!Data\"]}\" style=\"width:calc(100% - 30px); margin:10px; border:solid black 5px; border-radius: 5px; image-rendering: pixelated;\"></img>`\n    } else if (fileType == \"Audio\") {\n        outputArea.innerHTML = `<audio controls style=\"margin:10px; width:calc(100% - 30px); border: solid black 5px; border-radius: 34px;\"><source src=\"${file[\"!Data\"]}\" type=\"audio/mpeg\"></audio>`\n    } else if (fileType == \"Video\") {\n        outputArea.innerHTML = `<video controls style=\"margin:10px; width:calc(100% - 30px); border: solid black 5px; border-radius: 34px;\"><source src=\"${file[\"!Data\"]}\" type=\"video/mp4\"></video>`;\n    } else if (fileType === \"Text\" || fileType === \"JS\") {\n        const textContent = atob(file[\"!Data\"].split(',')[1]);\n        outputArea.innerHTML = `<textarea readonly style=\"width:calc(100% - 18px); min-height: calc(100vh - 18px); margin:10px; border: solid black 5px; border-radius: 5px; padding: 5px; white-space: pre-wrap;\">${textContent}</textarea>`;\n    } else if (fileType == \"HTML\") {\n        const htmlContent = atob(file[\"!Data\"].split(',')[1]);\n        const dataUrl = `data:text/html;charset=utf-8,${encodeURIComponent(htmlContent)}`;\n        outputArea.innerHTML = `<iframe src=\"${dataUrl}\" style=\"width:calc(100% - 30px); height: calc(100vh - 30px); margin:10px; border: solid black 5px; border-radius: 5px;\"></iframe>`;\n    } else {\n        alert(\"This file cannot be Previewed.\")\n    }\n}\n\nwindow.editFile = function() {\n    const file = notes[\"Files\"][path[path.length - 1]];\n    const fileType = file[\"!Type\"];\n\n    optionsArea.innerHTML = \"\";\n    outputArea.innerHTML = \"\";\n\n    if (fileType == \"Image\") {\n        const palette = [\n            '#000000', '#1D2B53', '#7E2553', '#008751',\n            '#AB5236', '#5F574F', '#C2C3C7', '#FFF1E8',\n            '#FF004D', '#FFA300', '#FFEC27', '#00E436',\n            '#29ADFF', '#83769C', '#FF77A8', '#FFCCAA'\n        ];\n        let selectedColor = palette[0];\n        let zoomLevel = 1;\n        const minZoom = 1;\n        const maxZoom = 32;\n        let panX = 0;\n        let panY = 0;\n        let isMouseLeftDown = false;\n        let isMouseMiddlePanning = false;\n        let isMouseLeftPanning = false;\n        let lastPointerX = 0;\n        let lastPointerY = 0;\n        let hoverPixelX = -1;\n        let hoverPixelY = -1;\n        let isPanModeActive = false;\n        let isEraseModeActive = false; // New state for erase mode\n\n        let touchPoints = {};\n        let isPinching = false;\n        let initialPinchDistance = 0;\n        let pinchStartZoom = 1;\n        let touchActionIdentifier = null;\n        let isTouchPanning = false;\n        // let touchStartX = 0; // No longer needed with potentialTap logic\n        // let touchStartY = 0; // No longer needed with potentialTap logic\n        // let touchStartTime = 0; // No longer needed with potentialTap logic\n        let potentialTap = false;\n        const tapThreshold = 10; // Increased threshold slightly\n        // const tapTimeThreshold = 300; // No longer needed for tap drawing\n\n        // --- Fixes Start: New State Variables ---\n        let isTouchDrawing = false; // To track drawing with touch\n        let lastPinchMidpoint = null; // To track pinch midpoint for correct panning\n        // --- Fixes End: New State Variables ---\n\n        const dataCanvas = document.createElement('canvas');\n        const dataCtx = dataCanvas.getContext('2d', { willReadFrequently: true });\n        dataCtx.imageSmoothingEnabled = false;\n\n        outputArea.innerHTML = `\n            <div style=\"display: flex; flex-direction: column; align-items: center; padding: 10px; height: calc(100vh - 150px);\">\n                <div id=\"canvasContainer\" style=\"overflow: hidden; border: 1px solid black; margin-bottom: 10px; width: 90%; height: 80%; position: relative; background-color: #cccccc; touch-action: none;\">\n                    <canvas id=\"displayCanvas\" style=\"position: absolute; top: 0; left: 0; image-rendering: pixelated; image-rendering: crisp-edges; cursor: crosshair; display: block;\"></canvas>\n                </div>\n                <div style=\"display: flex; justify-content: center; align-items: center; margin-bottom: 10px; flex-wrap: wrap;\">\n                    <div id=\"paletteContainer\" style=\"line-height: 0; margin-right: 15px;\"></div>\n                    <button id=\"panModeButton\" style=\"padding: 5px 10px; margin-left: 5px; border: 1px solid #888; border-radius: 4px; background-color: #f0f0f0; cursor: pointer;\">Pan: OFF</button>\n                    <button id=\"eraseModeButton\" style=\"padding: 5px 10px; margin-left: 5px; border: 1px solid #888; border-radius: 4px; background-color: #f0f0f0; cursor: pointer;\">Erase: OFF</button>\n                </div>\n                <div id=\"editorInfo\" style=\"font-size: 0.8em; color: #555; min-height: 1.2em;\"></div>\n            </div>\n        `;\n\n        const canvasContainer = document.getElementById('canvasContainer');\n        const displayCanvas = document.getElementById('displayCanvas');\n        const displayCtx = displayCanvas.getContext('2d');\n        displayCtx.imageSmoothingEnabled = false;\n        const paletteContainer = document.getElementById('paletteContainer');\n        const editorInfo = document.getElementById('editorInfo');\n        const panModeButton = document.getElementById('panModeButton');\n        const eraseModeButton = document.getElementById('eraseModeButton'); // Get erase button\n\n        palette.forEach((color, index) => {\n            const swatch = document.createElement('div');\n            swatch.style.width = '20px';\n            swatch.style.height = '20px';\n            swatch.style.backgroundColor = color;\n            swatch.style.border = '1px solid #ccc';\n            swatch.style.display = 'inline-block';\n            swatch.style.margin = '1px';\n            swatch.style.cursor = 'pointer';\n            if (index === 0) { swatch.style.border = '2px solid blue'; }\n            swatch.addEventListener('click', () => {\n                // Turn off erase mode when selecting a color\n                isEraseModeActive = false;\n                eraseModeButton.textContent = `Erase: OFF`;\n                eraseModeButton.style.backgroundColor = '#f0f0f0';\n\n                selectedColor = color;\n                Array.from(paletteContainer.children).forEach((child, i) => {\n                    child.style.border = i === index ? '2px solid blue' : '1px solid #ccc';\n                });\n                 // Update cursor if not in pan mode\n                 if (!isPanModeActive) {\n                    displayCanvas.style.cursor = 'crosshair';\n                 }\n            });\n            paletteContainer.appendChild(swatch);\n        });\n\n        panModeButton.addEventListener('click', () => {\n            isPanModeActive = !isPanModeActive;\n            panModeButton.textContent = `Pan: ${isPanModeActive ? 'ON' : 'OFF'}`;\n            panModeButton.style.backgroundColor = isPanModeActive ? '#a0d0a0' : '#f0f0f0';\n            // Adjust cursor based on both modes, prioritizing pan mode cursor\n            if (isPanModeActive) {\n                 displayCanvas.style.cursor = 'grab';\n            } else {\n                 displayCanvas.style.cursor = isEraseModeActive ? 'cell' : 'crosshair';\n            }\n            // Reset interaction states when toggling pan mode to avoid conflicts\n            isMouseLeftDown = false;\n            isTouchDrawing = false;\n            isMouseLeftPanning = false;\n            isTouchPanning = false;\n        });\n\n        eraseModeButton.addEventListener('click', () => {\n            isEraseModeActive = !isEraseModeActive;\n            eraseModeButton.textContent = `Erase: ${isEraseModeActive ? 'ON' : 'OFF'}`;\n            eraseModeButton.style.backgroundColor = isEraseModeActive ? '#ffaaaa' : '#f0f0f0';\n            if (isEraseModeActive) {\n                 Array.from(paletteContainer.children).forEach(child => {\n                     child.style.border = '1px solid #ccc'; // Deselect color swatches\n                 });\n            }\n             // Update cursor if not in pan mode\n            if (!isPanModeActive) {\n                 displayCanvas.style.cursor = isEraseModeActive ? 'cell' : 'crosshair';\n            }\n        });\n\n        function resizeAndRedraw() {\n            displayCanvas.width = canvasContainer.clientWidth;\n            displayCanvas.height = canvasContainer.clientHeight;\n            displayCtx.imageSmoothingEnabled = false;\n            redrawDisplayCanvas();\n           }\n\n        function redrawDisplayCanvas() {\n            if (!dataCanvas.width || !dataCanvas.height) return;\n            displayCtx.imageSmoothingEnabled = false;\n            displayCtx.fillStyle = '#cccccc';\n            displayCtx.fillRect(0, 0, displayCanvas.width, displayCanvas.height);\n            displayCtx.save();\n            displayCtx.scale(zoomLevel, zoomLevel);\n            displayCtx.translate(-panX, -panY);\n            displayCtx.drawImage(dataCanvas, 0, 0);\n            // Draw border around the image data\n            displayCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n            displayCtx.lineWidth = 1 / zoomLevel;\n            displayCtx.strokeRect(0, 0, dataCanvas.width, dataCanvas.height);\n            // Draw hover highlight only for mouse when not actively drawing/panning/pinching\n            if (hoverPixelX !== -1 && hoverPixelY !== -1 && !isPinching && Object.keys(touchPoints).length === 0 && !isMouseLeftDown && !isMouseMiddlePanning && !isMouseLeftPanning && !isTouchDrawing && !isTouchPanning) {\n                displayCtx.strokeStyle = \"rgba(255, 255, 255, 0.8)\";\n                displayCtx.lineWidth = 1 / zoomLevel;\n                // Slightly adjust strokeRect to center on the pixel lines\n                 displayCtx.strokeRect(hoverPixelX + (0.5 / zoomLevel) / 2, hoverPixelY + (0.5 / zoomLevel) / 2, 1 - (0.5 / zoomLevel), 1 - (0.5 / zoomLevel));\n             }\n            displayCtx.restore();\n            editorInfo.textContent = `Image: ${dataCanvas.width}x${dataCanvas.height}px | Zoom: ${zoomLevel.toFixed(2)}x | View: (${Math.round(panX)}, ${Math.round(panY)}) | Hover: (${hoverPixelX}, ${hoverPixelY})`;\n        }\n\n        function getPixelCoords(clientX, clientY) {\n             const rect = displayCanvas.getBoundingClientRect();\n             const canvasX = clientX - rect.left;\n             const canvasY = clientY - rect.top;\n             const imgX = (canvasX / zoomLevel) + panX;\n             const imgY = (canvasY / zoomLevel) + panY;\n             return { x: Math.floor(imgX), y: Math.floor(imgY) };\n        }\n\n        function getDistance(p1, p2) {\n             const dx = p1.clientX - p2.clientX;\n             const dy = p1.clientY - p2.clientY;\n             return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        function getMidpoint(p1, p2) {\n             return {\n                 clientX: (p1.clientX + p2.clientX) / 2,\n                 clientY: (p1.clientY + p2.clientY) / 2,\n             };\n        }\n\n        const img = new Image();\n        img.onload = () => {\n            dataCanvas.width = img.naturalWidth;\n            dataCanvas.height = img.naturalHeight;\n            dataCtx.imageSmoothingEnabled = false;\n            dataCtx.drawImage(img, 0, 0);\n            resizeAndRedraw();\n            window.addEventListener('resize', resizeAndRedraw);\n        };\n        img.onerror = () => { outputArea.innerHTML = `<p style=\"color: red;\">Error loading image data.</p>`; alert(\"Could not load the image for editing.\"); };\n        img.src = file[\"!Data\"];\n\n        function drawPixel(x, y) {\n             if (x >= 0 && x < dataCanvas.width && y >= 0 && y < dataCanvas.height) {\n                 if (isEraseModeActive) {\n                     dataCtx.clearRect(x, y, 1, 1); // Erase pixel\n                 } else {\n                     dataCtx.imageSmoothingEnabled = false;\n                     dataCtx.fillStyle = selectedColor;\n                     dataCtx.fillRect(x, y, 1, 1); // Draw pixel\n                 }\n                 redrawDisplayCanvas(); // Redraw needed after modifying data canvas\n             }\n        }\n\n        // --- Start Modified handlePointerDown ---\n        function handlePointerDown(identifier, clientX, clientY, isPrimary, eventSource) {\n            touchPoints[identifier] = { clientX, clientY, startX: clientX, startY: clientY, startTime: performance.now() };\n            const touchCount = Object.keys(touchPoints).length;\n\n            if (touchCount === 1 && isPrimary) {\n                touchActionIdentifier = identifier;\n                lastPointerX = clientX;\n                lastPointerY = clientY;\n                isTouchPanning = false;\n                isMouseLeftPanning = false;\n                isTouchDrawing = false; // Reset touch drawing flag\n                potentialTap = true;\n\n                if (isPanModeActive) {\n                    // Only activate panning flags if Pan Mode is ON\n                    if (eventSource === 'touch') { isTouchPanning = true; }\n                    if (eventSource === 'mouse') { isMouseLeftPanning = true; }\n                    displayCanvas.style.cursor = 'grabbing'; // Use 'grabbing' immediately\n                } else {\n                    // --- Drawing/Erasing Logic ---\n                    const coords = getPixelCoords(clientX, clientY); // Get coords for drawing\n                    if (eventSource === 'mouse') {\n                        isMouseLeftDown = true; // Mouse specific drawing flag\n                        drawPixel(coords.x, coords.y); // Draw on mouse down\n                    } else if (eventSource === 'touch') {\n                        isTouchDrawing = true; // Touch specific drawing flag\n                        drawPixel(coords.x, coords.y); // Draw on touch down\n                    }\n                    displayCanvas.style.cursor = isEraseModeActive ? 'cell' : 'crosshair';\n                }\n                hoverPixelX = -1; // Clear hover on interaction start\n                hoverPixelY = -1;\n            } else if (touchCount === 2) {\n                // --- Pinch Start Logic ---\n                isMouseLeftDown = false; // Cancel potential mouse draw\n                isTouchDrawing = false; // Cancel potential touch draw\n                isTouchPanning = false;\n                isMouseLeftPanning = false;\n                isPinching = true;\n                potentialTap = false;\n                const touches = Object.values(touchPoints);\n                initialPinchDistance = getDistance(touches[0], touches[1]);\n                pinchStartZoom = zoomLevel;\n                lastPinchMidpoint = getMidpoint(touches[0], touches[1]); // Initialize pinch midpoint\n                displayCanvas.style.cursor = 'move';\n                hoverPixelX = -1; // Clear hover on interaction start\n                hoverPixelY = -1;\n            }\n            // Redraw only if needed (pinch start, or initial draw pixel)\n            if (isPinching || (!isPanModeActive && (isMouseLeftDown || isTouchDrawing))) {\n               redrawDisplayCanvas();\n            }\n        }\n        // --- End Modified handlePointerDown ---\n\n        // --- Start Modified handlePointerMove ---\n        function handlePointerMove(identifier, clientX, clientY) {\n            // Hover logic (only for mouse when nothing else is active)\n            if (identifier === 'mouse' && !isMouseLeftDown && !isMouseMiddlePanning && !isMouseLeftPanning && Object.keys(touchPoints).length === 0 && !isPinching && !isTouchDrawing && !isTouchPanning) {\n                const coords = getPixelCoords(clientX, clientY);\n                let needsRedraw = false;\n                let newHoverX = -1, newHoverY = -1;\n                if (coords.x >= 0 && coords.x < dataCanvas.width && coords.y >= 0 && coords.y < dataCanvas.height) {\n                    newHoverX = coords.x; newHoverY = coords.y;\n                }\n                if (newHoverX !== hoverPixelX || newHoverY !== hoverPixelY) {\n                    hoverPixelX = newHoverX; hoverPixelY = newHoverY; needsRedraw = true;\n                }\n                if (needsRedraw) redrawDisplayCanvas();\n                return;\n            }\n\n            if (!touchPoints[identifier]) return; // Pointer not tracked (e.g., ended)\n\n            const currentPointer = touchPoints[identifier];\n            const startInfo = touchPoints[identifier]; // Keep start info if needed later\n            currentPointer.clientX = clientX;\n            currentPointer.clientY = clientY;\n\n            const touchCount = Object.keys(touchPoints).length;\n\n            // --- Pinch Zoom/Pan Logic (Corrected) ---\n            if (isPinching && touchCount === 2) {\n                potentialTap = false; // Pinching cancels tap\n                const touches = Object.values(touchPoints);\n                const currentDistance = getDistance(touches[0], touches[1]);\n                const currentMidpoint = getMidpoint(touches[0], touches[1]);\n\n                if (initialPinchDistance > 0 && lastPinchMidpoint) { // Check if pinch started correctly\n                    // 1. Calculate Zoom\n                    const zoomRatio = currentDistance / initialPinchDistance;\n                    const newZoomLevelTarget = pinchStartZoom * zoomRatio;\n                    const newZoomLevel = Math.max(minZoom, Math.min(maxZoom, newZoomLevelTarget));\n\n                    // 2. Calculate Pan adjustment due to Zoom (keep point under current midpoint)\n                    const rect = displayCanvas.getBoundingClientRect();\n                    const canvasMidX = currentMidpoint.clientX - rect.left;\n                    const canvasMidY = currentMidpoint.clientY - rect.top;\n\n                    // Image coords under the *current* midpoint using the *old* zoom/pan\n                    const imgXUnderMidpoint = (canvasMidX / zoomLevel) + panX;\n                    const imgYUnderMidpoint = (canvasMidY / zoomLevel) + panY;\n\n                    // Calculate the pan required JUST to counteract the zoom effect\n                    let zoomCorrectedPanX = imgXUnderMidpoint - (canvasMidX / newZoomLevel);\n                    let zoomCorrectedPanY = imgYUnderMidpoint - (canvasMidY / newZoomLevel);\n\n                    // 3. Calculate Pan adjustment due to Midpoint Translation\n                    const deltaMidX = currentMidpoint.clientX - lastPinchMidpoint.clientX;\n                    const deltaMidY = currentMidpoint.clientY - lastPinchMidpoint.clientY;\n\n                    // Apply the translation pan delta (subtract because pan = negative translation)\n                    // This moves the canvas view along with the fingers' movement\n                    let finalPanX = zoomCorrectedPanX - (deltaMidX / newZoomLevel);\n                    let finalPanY = zoomCorrectedPanY - (deltaMidY / newZoomLevel);\n\n                    // 4. Apply Changes and Redraw\n                    if (Math.abs(newZoomLevel - zoomLevel) > 0.001 || Math.abs(finalPanX - panX) > 0.1 || Math.abs(finalPanY - panY) > 0.1) {\n                        zoomLevel = newZoomLevel;\n                        panX = finalPanX;\n                        panY = finalPanY;\n                        redrawDisplayCanvas();\n                    }\n                }\n                // Update last midpoint for the next move event\n                lastPinchMidpoint = currentMidpoint; // Update last midpoint\n\n            }\n            // --- Single Pointer Move Logic (Pan or Draw) ---\n            else if (identifier === touchActionIdentifier && !isPinching) {\n                const dxPanDelta = clientX - lastPointerX;\n                const dyPanDelta = clientY - lastPointerY;\n\n                // Check if movement exceeds tap threshold (only relevant if tap wasn't already cancelled)\n                if (potentialTap) {\n                    const dxMoveTotal = clientX - startInfo.startX;\n                    const dyMoveTotal = clientY - startInfo.startY;\n                    const distanceMoved = Math.sqrt(dxMoveTotal * dxMoveTotal + dyMoveTotal * dyMoveTotal);\n                    if (distanceMoved > tapThreshold) {\n                        potentialTap = false; // It's a drag, not a tap\n                        // If pan mode just turned on because of drag starting, update cursor\n                        if (isPanModeActive && !isTouchPanning && !isMouseLeftPanning) {\n                             if (identifier === 'mouse') isMouseLeftPanning = true;\n                             else isTouchPanning = true;\n                             displayCanvas.style.cursor = 'grabbing';\n                        }\n                    }\n                }\n\n                // Pan if corresponding pan flag is active AND pan mode is on\n                if ((isTouchPanning || isMouseLeftPanning) && isPanModeActive) {\n                    potentialTap = false; // Dragging always cancels tap\n                    panX -= dxPanDelta / zoomLevel;\n                    panY -= dyPanDelta / zoomLevel;\n                    if (displayCanvas.style.cursor !== 'grabbing') { displayCanvas.style.cursor = 'grabbing';}\n                    redrawDisplayCanvas();\n                }\n                // Draw/Erase with MOUSE if mouse draw flag is active and NOT in pan mode\n                else if (isMouseLeftDown && !isPanModeActive) {\n                    potentialTap = false; // Mouse Dragging cancels tap\n                    const coords = getPixelCoords(clientX, clientY);\n                    drawPixel(coords.x, coords.y); // Draw/Erase on mouse drag\n                }\n                // Draw/Erase with TOUCH if touch draw flag is active and NOT in pan mode\n                else if (isTouchDrawing && !isPanModeActive) { // Added Touch Drawing on move\n                    potentialTap = false; // Touch Dragging cancels tap\n                    const coords = getPixelCoords(clientX, clientY);\n                    drawPixel(coords.x, coords.y); // Draw/Erase on touch drag\n                }\n\n                lastPointerX = clientX;\n                lastPointerY = clientY;\n            }\n        }\n        // --- End Modified handlePointerMove ---\n\n        // --- Start Modified handlePointerUp ---\n        function handlePointerUp(identifier, clientX, clientY) {\n            const startInfo = touchPoints[identifier]; // Keep for potential future use\n            const touchCountBeforeEnd = Object.keys(touchPoints).length;\n\n            delete touchPoints[identifier];\n            const touchCountAfterEnd = Object.keys(touchPoints).length;\n\n            let cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair');\n\n            // --- Pinch End Logic ---\n            if (isPinching && touchCountBeforeEnd === 2 && touchCountAfterEnd < 2) {\n                isPinching = false;\n                initialPinchDistance = 0;\n                lastPinchMidpoint = null; // Reset pinch midpoint tracker\n                if (touchCountAfterEnd === 1) {\n                    // Transitioning from pinch to single touch - reset state for the remaining touch\n                    const remainingTouchId = Object.keys(touchPoints)[0];\n                    const remainingTouch = touchPoints[remainingTouchId];\n                    touchActionIdentifier = remainingTouchId;\n                    lastPointerX = remainingTouch.clientX; // Update last pointer coords based on remaining touch\n                    lastPointerY = remainingTouch.clientY;\n                    isTouchPanning = false; // Reset specific action states\n                    isTouchDrawing = false;\n                    potentialTap = false; // Pinch ending shouldn't result in a tap action\n\n                    // Re-evaluate if the remaining touch should pan or draw based on current mode\n                     if (isPanModeActive) {\n                        isTouchPanning = true; // Immediately set for potential drag\n                        cursor = 'grabbing';\n                     } else {\n                         // Not pan mode, set cursor for drawing/erasing but don't assume drawing starts\n                         isTouchDrawing = false;\n                         cursor = isEraseModeActive ? 'cell' : 'crosshair';\n                     }\n                     // Update the remaining touch point's start info in case it becomes a tap\n                     remainingTouch.startX = remainingTouch.clientX;\n                     remainingTouch.startY = remainingTouch.clientY;\n                     remainingTouch.startTime = performance.now();\n                     potentialTap = true; // A tap is possible again with the single remaining finger\n\n\n                } else {\n                    // Pinch ended and no touches remain\n                    touchActionIdentifier = null;\n                }\n            }\n            // --- Single Pointer End Logic ---\n            else if (identifier === touchActionIdentifier) {\n\n                // --- Tap Logic (Simplified: only check if potentialTap wasn't cancelled by drag) ---\n                 if (!isPanModeActive && !isTouchDrawing && !isMouseLeftDown && potentialTap && startInfo) {\n                     // This case is less likely now as drawing happens on down/move,\n                     // but keep as a fallback for a very quick tap that didn't trigger move draw.\n                     // Note: Removed time check, relying only on distance threshold being met.\n                     const dxMoveTotal = clientX - startInfo.startX;\n                     const dyMoveTotal = clientY - startInfo.startY;\n                     const distanceMoved = Math.sqrt(dxMoveTotal * dxMoveTotal + dyMoveTotal * dyMoveTotal);\n\n                     if (distanceMoved <= tapThreshold) {\n                        // It was a valid tap, ensure the pixel gets drawn (might be redundant)\n                        const coords = getPixelCoords(clientX, clientY);\n                        // console.log(\"Tap detected, drawing at:\", coords); // Optional debug log\n                        drawPixel(coords.x, coords.y);\n                    }\n                 }\n\n\n                // Reset flags related to the primary action pointer\n                isTouchPanning = false;\n                isMouseLeftDown = false;\n                isMouseLeftPanning = false;\n                isTouchDrawing = false; // Reset touch drawing flag\n                potentialTap = false;\n                touchActionIdentifier = null; // No primary action touch anymore\n            }\n\n            // --- General Cleanup when no pointers remain ---\n            if (touchCountAfterEnd === 0) {\n                isTouchPanning = false;\n                isMouseLeftDown = false;\n                isMouseLeftPanning = false;\n                isTouchDrawing = false; // Reset touch drawing flag\n                isPinching = false;\n                potentialTap = false;\n                touchActionIdentifier = null;\n                lastPinchMidpoint = null; // Reset pinch midpoint tracker\n                cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair'); // Ensure cursor resets fully\n            }\n\n            displayCanvas.style.cursor = cursor; // Set cursor based on mode after action ends\n            redrawDisplayCanvas(); // Redraw to remove hover effects etc.\n        }\n        // --- End Modified handlePointerUp ---\n\n\n        // --- MOUSE EVENT LISTENERS (Largely Unchanged) ---\n        displayCanvas.addEventListener('mousedown', (e) => {\n            if (e.button === 0) { // Left mouse button\n                handlePointerDown('mouse', e.clientX, e.clientY, true, 'mouse');\n            } else if (e.button === 1) { // Middle mouse button (Wheel click)\n                isMouseMiddlePanning = true;\n                lastPointerX = e.clientX;\n                lastPointerY = e.clientY;\n                displayCanvas.style.cursor = 'grabbing';\n                e.preventDefault(); // Prevent default middle-click scroll behavior\n            }\n        });\n\n        displayCanvas.addEventListener('mousemove', (e) => {\n             // Handle middle mouse button panning first if active\n             if (isMouseMiddlePanning && (e.buttons & 4)) { // Check if middle button is still held\n                 const dx = e.clientX - lastPointerX;\n                 const dy = e.clientY - lastPointerY;\n                 panX -= dx / zoomLevel;\n                 panY -= dy / zoomLevel;\n                 lastPointerX = e.clientX;\n                 lastPointerY = e.clientY;\n                 redrawDisplayCanvas();\n             }\n             else {\n                 // If not middle-panning, handle as regular pointer move (hover, left-drag draw/pan)\n                 handlePointerMove('mouse', e.clientX, e.clientY);\n             }\n         });\n\n        displayCanvas.addEventListener('mouseup', (e) => {\n            if (e.button === 0) { // Left mouse button\n                handlePointerUp('mouse', e.clientX, e.clientY);\n            } else if (e.button === 1) { // Middle mouse button\n                isMouseMiddlePanning = false;\n                 // Reset cursor based on current mode\n                 displayCanvas.style.cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair');\n                 redrawDisplayCanvas(); // Redraw to potentially clear hover state if mouse left canvas while panning\n             }\n         });\n\n        displayCanvas.addEventListener('mouseleave', (e) => {\n             // If left mouse button was down (drawing or panning), release it\n             if (touchPoints['mouse']) {\n                 handlePointerUp('mouse', e.clientX, e.clientY);\n             }\n             // If middle mouse button was down (panning), release it\n             if (isMouseMiddlePanning) {\n                 isMouseMiddlePanning = false;\n                 displayCanvas.style.cursor = isPanModeActive ? 'grab' : (isEraseModeActive ? 'cell' : 'crosshair');\n             }\n             // Clear hover state\n             if (hoverPixelX !== -1 || hoverPixelY !== -1) {\n                 hoverPixelX = -1;\n                 hoverPixelY = -1;\n                 redrawDisplayCanvas();\n             }\n         });\n\n        displayCanvas.addEventListener('wheel', (e) => {\n            e.preventDefault(); // Prevent page scrolling\n            const rect = displayCanvas.getBoundingClientRect();\n            const mouseX = e.clientX - rect.left; // Mouse position relative to canvas\n            const mouseY = e.clientY - rect.top;\n\n            // Calculate image coordinates under mouse before zoom\n            const imgXBefore = (mouseX / zoomLevel) + panX;\n            const imgYBefore = (mouseY / zoomLevel) + panY;\n\n            // Calculate new zoom level\n            const zoomFactor = 1.2;\n            let newZoomLevel;\n            if (e.deltaY < 0) { // Zoom in\n                newZoomLevel = Math.min(maxZoom, zoomLevel * zoomFactor);\n            } else { // Zoom out\n                newZoomLevel = Math.max(minZoom, zoomLevel / zoomFactor);\n            }\n\n            // Only update if zoom actually changed significantly\n            if(Math.abs(newZoomLevel - zoomLevel) < 0.001) return;\n\n            // Calculate new pan values to keep the point under the mouse stationary\n            panX = imgXBefore - (mouseX / newZoomLevel);\n            panY = imgYBefore - (mouseY / newZoomLevel);\n\n            zoomLevel = newZoomLevel;\n\n            // Update hover pixel based on new zoom/pan if mouse is over canvas\n             handlePointerMove('mouse', e.clientX, e.clientY); // Re-evaluate hover position\n\n             redrawDisplayCanvas();\n        });\n\n        // --- TOUCH EVENT LISTENERS (Using Pointer Handlers) ---\n        displayCanvas.addEventListener('touchstart', (e) => {\n            e.preventDefault(); // Essential to prevent default touch actions like scrolling\n            for (let i = 0; i < e.changedTouches.length; i++) {\n                const touch = e.changedTouches[i];\n                // Determine if this is the primary touch point (the first one down)\n                 const isPrimary = Object.keys(touchPoints).length === 0 && i === 0;\n                 handlePointerDown(touch.identifier, touch.clientX, touch.clientY, isPrimary, 'touch');\n             }\n        }, { passive: false }); // Need passive: false to call preventDefault\n\n        displayCanvas.addEventListener('touchmove', (e) => {\n            e.preventDefault(); // Essential to prevent scrolling during draw/pan/pinch\n            for (let i = 0; i < e.changedTouches.length; i++) {\n                const touch = e.changedTouches[i];\n                // Only process move events for touches we are actively tracking\n                 if (touchPoints[touch.identifier]) {\n                     handlePointerMove(touch.identifier, touch.clientX, touch.clientY);\n                 }\n             }\n        }, { passive: false });\n\n        displayCanvas.addEventListener('touchend', (e) => {\n            e.preventDefault();\n            for (let i = 0; i < e.changedTouches.length; i++) {\n                const touch = e.changedTouches[i];\n                // Only process end events for touches we were tracking\n                 if (touchPoints[touch.identifier]) {\n                     handlePointerUp(touch.identifier, touch.clientX, touch.clientY);\n                 }\n             }\n        }, { passive: false });\n\n        displayCanvas.addEventListener('touchcancel', (e) => {\n           // Treat cancel the same as touchend\n           e.preventDefault();\n           for (let i = 0; i < e.changedTouches.length; i++) {\n               const touch = e.changedTouches[i];\n               if (touchPoints[touch.identifier]) {\n                  handlePointerUp(touch.identifier, touch.clientX, touch.clientY);\n               }\n           }\n        }, { passive: false });\n\n\n        // --- SAVE FUNCTIONALITY (Unchanged) ---\n        const saveSprite = () => {\n             try {\n                 const newDataUrl = dataCanvas.toDataURL(); // Get image data as base64\n                 file[\"!Data\"] = newDataUrl; // Update the notes object\n                 saveData(); // Assumes this function exists elsewhere to save the 'notes' object\n                 showOption(); // Assumes this function exists elsewhere to refresh UI\n                 alert(\"Sprite saved successfully!\");\n             } catch (error) {\n                 console.error(\"Error saving sprite:\", error);\n                 alert(\"Error saving sprite.\");\n             }\n         };\n         // Assumes newOptionButton function exists elsewhere\n         newOptionButton(\"Save Sprite\", \"#393939\", saveSprite);\n\n    } else {\n        alert(\"This file type cannot be Edited.\");\n        showOption(); // Go back or refresh UI\n    }\n};\n\nwindow.renameFile = function() {\n    const newFileName = prompt(\"Please enter the new name for the file.\");\n    if (!(newFileName in notes[\"Files\"])) {\n        notes[\"Files\"][newFileName] = notes[\"Files\"][path[path.length - 1]];\n        delete notes[\"Files\"][path.pop()];\n        const tempUpload = notes[\"Files\"][\"Upload\"];\n        const tempCustomImage = notes[\"Files\"][\"Create Image\"];\n        const tempCustomSFX = notes[\"Files\"][\"Create SFX\"];\n        delete notes[\"Files\"][\"Upload\"];\n        delete notes[\"Files\"][\"Create Image\"];\n        delete notes[\"Files\"][\"Create SFX\"];\n        notes[\"Files\"][\"Create Image\"] = tempCustomImage;\n        notes[\"Files\"][\"Create SFX\"] = tempCustomSFX;\n        notes[\"Files\"][\"Upload\"] = tempUpload;\n        saveData();\n    } else {\n        alert(\"File with that name already exists.\");\n    }\n    showOption();\n}\n\nwindow.downloadFile = function() {\n    const byteCharacters = atob(notes[\"Files\"][path[path.length - 1]][\"!Data\"].split(',')[1]);\n    const byteArrays = [];\n    for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n        const slice = byteCharacters.slice(offset, offset + 512);\n        const byteNumbers = new Array(slice.length);\n        for (let i = 0; i < slice.length; i++) {\n            byteNumbers[i] = slice.charCodeAt(i);\n        }\n        const byteArray = new Uint8Array(byteNumbers);\n        byteArrays.push(byteArray);\n    }\n    const blob = new Blob(byteArrays, { type: notes[\"Files\"][path[path.length - 1]][\"!Data\"].split(',')[0].split(':')[1].split(';')[0] });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = notes[\"Files\"][path[path.length - 1]][\"!Name\"];\n    link.click();\n    URL.revokeObjectURL(url);\n    showOption();\n}\n\nwindow.deleteFile = function() {\n    delete notes[\"Files\"][path.pop()];\n    showOption();\n}"
    },
    "!Save": false
};
//MARK

        // D A T A B A S E   F O R   A U T O S A V E
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("ToolKitDB", 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    window.db = request.result;
                    resolve();
                };
                request.onupgradeneeded = (event) => {
                    window.db = event.target.result;
                    window.db.createObjectStore("data", { keyPath: "id" });
                };
            });
        }
        
        function saveData() {
            return window.openDB().then(() => {
                const transaction = window.db.transaction(["data"], "readwrite");
                const objectStore = transaction.objectStore("data");
                const request = objectStore.put({
                    id: "allData",
                    notes: JSON.stringify(notes)
                });
                console.log("Saved Data")
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            });
        }
        
        function loadData() {
            return window.openDB().then(() => {
                const transaction = window.db.transaction(["data"], "readonly");
                const objectStore = transaction.objectStore("data");
                const request = objectStore.get("allData");
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        if (request.result) {
                            const oldNotes = JSON.parse(JSON.stringify(notes))
                            notes = JSON.parse(request.result.notes);
                            if (!notes["!Save"]) notes = oldNotes;
                            resolve({
                                notes: true
                            });
                        } else {
                            resolve({ notes : null });
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            });
        }
        
        function resetData() {
            return new Promise((resolve, reject) => {
                console.log("Data Reset")
                const request = indexedDB.deleteDatabase("ScriptingDexDB");
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve();
            });
        }
        
        // S T A R T
        loadData().then(data => {
            if (data.notes === null) {
                window.saveData();
            }
            if (!notes["!Save"]) {
                console.log("Saving Disabled so running default Code.");
            } else {
                console.log("Saving Enabled so running most recent Auto-Save.");
            }
            const startJS = new Function(notes["!Functions"]["Start"].substring(2));
            startJS();
        });

    </script>
    <script>
        /*
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./service-worker.js')
            .then(registration => {
              console.log('Service Worker registered with scope:', registration.scope);
            })
            .catch(error => {
              console.error('Service Worker registration failed:', error);
            });
        }
        */
    </script>

</body></html>
