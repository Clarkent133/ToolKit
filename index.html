<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CH</title>
    <style>
        .customStyling {
            border-radius:4px;
            border:solid black 2px;
        }
    </style>
</head>
<body style="margin:0;">
    <canvas id="cnv" style="width:100%; height:100dvh; position:fixed; z-index:1;"></canvas>
    <div id="editButton" class="customStyling" style="width:34px; height:34px; position:fixed; top:10px; right:10px; cursor:pointer; z-index:30; display:flex; justify-content:center; align-items:center; text-align:center; font-size:24px;">E</div>

    <div id="mainArea" style="width:calc(100% - 10px); height:calc(25% - 10px); position:fixed; bottom:0px; display:flex; flex-direction:column-reverse; z-index:10; transition:height 0.6s ease-in-out; padding:5px; gap:5px;">
        <div id="fullSelectionArea" style="width:100%; min-height:40px; display:flex; gap:5px;">
            <div id="prevSelectionArea" class="customStyling" style="min-width:36px; height:calc(100% - 4px); display:flex; justify-content:center; align-items:center; text-align:center; font-size:24px; cursor:pointer;">&lt;</div>
            <div id="selectionArea" class="customStyling" style="width:calc(100% - 4px); height:calc(100% - 4px); display:flex; justify-content:center; align-items:center; text-align:center; font-size:24px; cursor:pointer;"></div>
            <div id="nextSelectionArea" class="customStyling" style="min-width:36px; height:calc(100% - 4px); display:flex; justify-content:center; align-items:center; text-align:center; font-size:24px; cursor:pointer;">&gt;</div>
        </div>
        <div id="textArea" class="customStyling" style="width:calc(100% - 14px); height:calc(100% - 14px); padding:5px; font-size:16px; overflow-y:auto;"></div>
    </div>

    <script src="/qrCode.js"></script>
    
    <script>
        const textArea = document.getElementById("textArea");
        const mainArea = document.getElementById("mainArea");
        const menuButton = document.getElementById("editButton");
        const fullSelectionArea = document.getElementById("fullSelectionArea");
        const prevSelectionArea = document.getElementById("prevSelectionArea");
        const selectionArea = document.getElementById("selectionArea");
        const nextSelectionArea = document.getElementById("nextSelectionArea");
        const cnv = document.getElementById("cnv");
        const ctx = cnv.getContext("2d");
        const DB_NAME = "VN_DB"
        const STORE = "vnStore";

        let flags = {};
        let vars = {};
        let code = "";
        let multiLine = "";
        let addingCode = false;
        let addingText = false;
        let textToDisplay = "";
        let textDisplayed = "";
        let persistent = {};
        let vn = `

        <div style="width:100%; height:100%; display:flex; justify-content:center; align-items:center; text-align:center; font-size:32px;">Loading ...</div>

        `;
        
        prepareVN();




        function typeLoop() {
            if (textDisplayed !== textToDisplay) {
                if (textToDisplay.startsWith(textDisplayed)) {
                    textDisplayed += textToDisplay[textDisplayed.length];
                } else {
                    textDisplayed = "";
                }
                textArea.innerHTML = textDisplayed;
            }
        }

        const typing = setInterval(typeLoop, 5);


        function prepareVN() {
            vn = vn.split("\n").map(line => line.trim()).filter(line => line !== ""); // CONVERTS STRING TO ARRAY WITHOUT LEADING SPACES OR BLANK LINES
            vn.forEach((elem, i) => {if (elem.startsWith("#")) flags[elem.substring(1).trim()] = i}); // POPULATES FLAGS 
        }

        function checkVar(str) {
            if (str.includes("==")) {
                let name = (!isNaN(parseInt(str.split("==")[0].trim()))) ? parseInt(str.split("==")[0].trim()) : str.split("==")[0].trim();
                let val = (!isNaN(parseInt(str.split("==")[1].trim()))) ? parseInt(str.split("==")[1].trim()) : str.split("==")[1].trim();
                if (name in vars) return (vars[name] == val)
            } else if (str.includes("=")) {
                let name = (!isNaN(parseInt(str.split("=")[0].trim()))) ? parseInt(str.split("=")[0].trim()) : str.split("=")[0].trim();
                let val = (!isNaN(parseInt(str.split("=")[1].trim()))) ? parseInt(str.split("=")[1].trim()) : str.split("=")[1].trim();
                vars[name] = val;
                return true;
            } else if (str.includes("<")) {
                let name = (!isNaN(parseInt(str.split("<")[0].trim()))) ? parseInt(str.split("<")[0].trim()) : str.split("<")[0].trim();
                let val = (!isNaN(parseInt(str.split("<")[1].trim()))) ? parseInt(str.split("<")[1].trim()) : str.split("<")[1].trim();
                if (name in vars) return (vars[name] < val)
            } else if (str.includes(">")) {
                let name = (!isNaN(parseInt(str.split(">")[0].trim()))) ? parseInt(str.split(">")[0].trim()) : str.split(">")[0].trim();
                let val = (!isNaN(parseInt(str.split(">")[1].trim()))) ? parseInt(str.split(">")[1].trim()) : str.split(">")[1].trim();
                if (name in vars) return (vars[name] > val)
            }
            return false;
        }

        function progressVN(track = 0) {

            editButton.onclick = function() {
                mainArea.style.height = "calc(100% - 10px)";
                fullSelectionArea.style.display = "none";
                textDisplayed = "";
                textToDisplay = "";
                textArea.innerHTML = "";
                textArea.onclick = function() {};
                let editor = document.createElement("textarea");
                editor.wrap = "off";
                editor.style.cssText = 'width:calc(100% - 10px); height:calc(100% - 14px); padding:5px; margin:0px; border:0px; resize:none; background-color:rgba(0,0,0,0);';
                for (let i=0; i<vn.length; i++) {
                    if (vn[i].startsWith("#")) vn[i] = "\n\n" + vn[i]
                }
                editor.value = vn.join("\n");
                textArea.appendChild(editor);
                editButton.innerHTML = "S";
                editButton.onclick = function() {
                    vn = editor.value;
                    saveVN();
                    flags = {};
                    editButton.innerHTML = "E";
                    prepareVN();
                    textArea.innerHTML = "";
                    progressVN();
                }
            }

            textArea.onclick = function() {
                if (textDisplayed != textToDisplay) {
                    textDisplayed = textToDisplay;
                    textArea.innerHTML = textDisplayed;
                } else {
                    mainArea.style.height = (mainArea.style.height == 'calc(100% - 10px)') ? "calc(25% - 10px)" : 'calc(100% - 10px)';
                }
            }

            fullSelectionArea.style.display = "flex";

            let line = vn[track];

            if (addingCode) {
                if (line.startsWith("]]")) {
                    addingCode = false;
                    let newJS = new Function(code);
                    newJS();
                } else {
                    code += "\n" + line;
                }
                progressVN(track + 1);
            } else if (line.startsWith('"""') && !addingText) {
                addingText = true;
                progressVN(track + 1);
            } else if (line.startsWith("#")) { // FLAG
                progressVN(track + 1);
            } else if (line.startsWith("->")) { // JUMP
                if (line.substring(2).trim() in flags) {
                    progressVN(flags[line.substring(2).trim()]);
                } else {
                    progressVN(track + 1);
                }
            } else if (line.startsWith("?")) { // DECISION
                console.log("Decisions need text prior.");
                progressVN(track + 1);
            } else if (line.startsWith("[[")) { // CODE
                code = "\n";
                addingCode = true;
                progressVN(track + 1);
            } else if (line.startsWith("[") && line.endsWith("]")) { // VAR DECLERATION
                const broken = line.slice(1, line.length - 1).split("=")
                const name = broken.shift().trim();
                const value = broken.join("=").trim();
                vars[name] = (!isNaN(parseInt(value))) ? parseInt(value) : value;
                progressVN(track + 1);
            } else if (line.startsWith(">>")) { // USER INPUT
                const userInput = prompt(line.split("=")[1].trim());
                vars[line.split("=")[0].substring(2).trim()] = (!isNaN(parseInt(userInput))) ? parseInt(userInput) : userInput;
                progressVN(track + 1);
            } else { // TEXT

                if (addingText) {
                    if (line.startsWith('"""')) {
                        line = multiLine;
                        addingText = false;
                        multiLine = "";
                    } else {
                        multiLine += line;
                        return progressVN(track + 1);
                    }
                }
                
                let result = line.replace(/\[(.+?)\]/g, (_, key) => {
                    return vars[key] !== undefined ? vars[key] : `[${key}]`;
                });

                textToDisplay = result;

                if (track < vn.length - 1) {
                    selectionArea.style.display = "flex";
                    if (vn[track + 1].startsWith("?")) {
                        prevSelectionArea.style.display = "flex";
                        nextSelectionArea.style.display = "flex";
                        prevSelectionArea.onclick = function() {cycleSelections(-1)};
                        nextSelectionArea.onclick = function() {cycleSelections(1)};
                        let selections = vn[track + 1].substring(1).split("|").filter(option => option.split("->")[1].trim() in flags);
                        for (let i=selections.length-1; i>=0; i--) {
                            if (selections[i].split("->")[0].trim().includes("[")) {
                                const varCheck = checkVar(selections[i].split("->")[0].trim().split("[")[1].split("]")[0].trim()); // REMOVES OPTIONS WITH FALSE VAR CHECKS
                                if (!varCheck) selections.splice(i, 1)
                            }
                        }
                        if (selections.length == 1) {
                            prevSelectionArea.style.display = "none";
                            nextSelectionArea.style.display = "none";
                        }
                        let sel = 0;
                        function cycleSelections(dir) {
                            if (dir == 1) sel = (sel < (selections.length - 1)) ? sel + 1 : 0;
                            if (dir == -1) sel = (sel > 0) ? sel - 1 : (selections.length - 1);
                            if (selections[sel].split("->")[0].trim().includes("[")) {
                                const title = selections[sel].split("->")[0].trim().split("]")[1].trim();
                                selectionArea.innerHTML = title.toUpperCase();
                            } else {
                                selectionArea.innerHTML = selections[sel].split("->")[0].trim().toUpperCase();
                            }
                            selectionArea.onclick = function() {
                                progressVN(flags[selections[sel].split("->")[1].trim()]);
                            }
                        }
                        cycleSelections(0);
                    } else {
                        prevSelectionArea.style.display = "none";
                        nextSelectionArea.style.display = "none";
                        selectionArea.innerHTML = "CONTINUE";
                        selectionArea.onclick = function() {
                            progressVN(track + 1);
                        }
                    }
                } else {
                    prevSelectionArea.style.display = "none";
                    nextSelectionArea.style.display = "none";
                    selectionArea.style.display = "none";
                }
            }
        }


        function handleInputs(canvas) {
            if (!canvas) throw new Error("Need a canvas");

            if (window.inputs && window.inputs.destroy) window.inputs.destroy();

            const keysDown = new Set(), keysConsumed = new Set();
            let pointerDown = false, pointerPos = { x: 0, y: 0 };
            const clickQueue = [];

            const keyFromEvent = e => (e.key.length === 1 ? e.key.toLowerCase() : e.key);
            const keyFromArg = k => (k.length === 1 ? k.toLowerCase() : k);
            const coords = (cx, cy) => {
                const r = canvas.getBoundingClientRect();
                return { x: (cx - r.left) * (canvas.width / r.width), y: (cy - r.top) * (canvas.height / r.height) };
            };
            const inRect = (px, py, x, y, w, h) => px >= x && py >= y && px <= x + w && py <= y + h;

            const inputs = {
                btn(a, b, c, d) {
                    if (arguments.length === 1 && typeof a === "string") return keysDown.has(keyFromArg(a));
                    if (arguments.length === 4) return pointerDown && inRect(pointerPos.x, pointerPos.y, a, b, c, d);
                    return false;
                },
                btnP(a, b, c, d) {
                    if (arguments.length === 1 && typeof a === "string") {
                        const k = keyFromArg(a);
                        if (keysDown.has(k) && !keysConsumed.has(k)) return keysConsumed.add(k), true;
                        return false;
                    }
                    if (arguments.length === 4) {
                        for (let i = 0; i < clickQueue.length; i++) {
                            const p = clickQueue[i];
                            if (inRect(p.x, p.y, a, b, c, d)) return clickQueue.splice(i, 1), true;
                        }
                    }
                    return false;
                },
                destroy() {
                    window.removeEventListener("keydown", kd, true);
                    window.removeEventListener("keyup", ku, true);
                    window.removeEventListener("blur", bl, true);
                    canvas.removeEventListener("pointermove", pm, true);
                    canvas.removeEventListener("pointerdown", pd, true);
                    canvas.removeEventListener("pointerup", pu, true);
                    if (window.inputs === inputs) delete window.inputs;
                }
            };

            const kd = e => keysDown.add(keyFromEvent(e));
            const ku = e => { const k = keyFromEvent(e); keysDown.delete(k); keysConsumed.delete(k); };
            const bl = () => { keysDown.clear(); keysConsumed.clear(); pointerDown = false; };
            const pm = e => { pointerPos = coords(e.clientX, e.clientY); };
            const pd = e => {
                if (e.button !== 0) return;
                if (!canvas.hasAttribute("tabindex")) canvas.setAttribute("tabindex", "0");
                canvas.focus();
                pointerDown = true;
                pointerPos = coords(e.clientX, e.clientY);
                clickQueue.push(pointerPos);
            };
            const pu = e => { if (e.button === 0) pointerDown = false; };

            window.addEventListener("keydown", kd, true);
            window.addEventListener("keyup", ku, true);
            window.addEventListener("blur", bl, true);
            canvas.addEventListener("pointermove", pm, true);
            canvas.addEventListener("pointerdown", pd, true);
            canvas.addEventListener("pointerup", pu, true);

            return (window.inputs = inputs);
        }


        const p2p = {
            id: 0,
            connections: [],
            peerConnections: [],
            dataChannels: [],
            stunServer: { urls: "stun:stun.l.google.com:19302" },
        
            host: function () {
                const peer = new RTCPeerConnection({ iceServers: [p2p.stunServer] });
                const dataChannel = peer.createDataChannel("data");
        
                const newId = p2p.connections.length + 1;
                p2p.peerConnections[newId] = peer;
                p2p.dataChannels[newId] = dataChannel;
                p2p.connections.push(newId);
        
                dataChannel.onmessage = (event) => {
                    const { from, to, message } = JSON.parse(event.data);
        
                    if (to === 0 || to === null || to === undefined) {
                        p2p.onReceive(message, from);
                        p2p.dataChannels.forEach((channel, i) => {
                            if (i !== 0 && i !== from && channel?.readyState === "open") {
                                channel.send(JSON.stringify({ from, message }));
                            }
                        });
                    } else if (to === "all") {
                        p2p.dataChannels.forEach((channel, i) => {
                            if (i !== 0 && i !== from && channel?.readyState === "open") {
                                channel.send(JSON.stringify({ from, message }));
                            }
                        });
                    } else {
                        const targetChannel = p2p.dataChannels[to];
                        if (targetChannel?.readyState === "open") {
                            targetChannel.send(JSON.stringify({ from, message }));
                        }
                    }
                };
        
                peer.onicecandidate = (e) => {
                    if (e.candidate === null) {
                        console.log(`OFFER FOR CLIENT ID ${newId}:`, JSON.stringify(peer.localDescription));
                    }
                };
        
                peer.createOffer()
                    .then(offer => peer.setLocalDescription(offer))
                    .catch(err => console.error("Offer creation failed:", err));
            },
        
            join: function (hostOfferObj) {
                const hostOffer = hostOfferObj;
                const peer = new RTCPeerConnection({ iceServers: [p2p.stunServer] });
        
                p2p.id = 1;
                p2p.peerConnections[0] = peer;
        
                peer.ondatachannel = (event) => {
                    const channel = event.channel;
                    p2p.dataChannels[0] = channel;
        
                    channel.onopen = () => {
                        console.log("Connected to host!");
                    };
        
                    channel.onmessage = (event) => {
                        const { from, message } = JSON.parse(event.data);
                        p2p.onReceive(message, from);
                    };
                };
        
                peer.onicecandidate = (e) => {
                    if (e.candidate === null) {
                        console.log("ANSWER FOR HOST:", JSON.stringify(peer.localDescription));
                    }
                };
        
                peer.setRemoteDescription(new RTCSessionDescription(hostOffer))
                    .then(() => peer.createAnswer())
                    .then(answer => peer.setLocalDescription(answer))
                    .catch(err => console.error("Client join failed:", err));
            },
        
            completeConnection: function (answerObj) {
                const clientId = p2p.connections[p2p.connections.length - 1];
                const answer = answerObj;
                const peer = p2p.peerConnections[clientId];
        
                if (!peer) return;
        
                peer.setRemoteDescription(new RTCSessionDescription(answer)).then(() => {
                    console.log(`Connection with client ${clientId} established.`);
        
                    p2p.dataChannels.forEach((channel, i) => {
                        if (channel?.readyState === "open" && i !== 0 && i !== clientId) {
                            channel.send(JSON.stringify({
                                from: 0,
                                message: `New player connected: ID ${clientId}`
                            }));
                        }
                    });
        
                    const newClientChannel = p2p.dataChannels[clientId];
                    if (newClientChannel?.readyState === "open") {
                        p2p.connections.forEach(id => {
                            if (id !== clientId) {
                                newClientChannel.send(JSON.stringify({
                                    from: 0,
                                    message: `Existing player: ID ${id}`
                                }));
                            }
                        });
                    }
                });
            },
        
            send: function (message, id = null) {
                const payload = { from: p2p.id, message };
        
                if (p2p.id === 0) {
                    if (id !== null && p2p.dataChannels[id]?.readyState === "open") {
                        p2p.dataChannels[id].send(JSON.stringify(payload));
                    } else {
                        p2p.dataChannels.forEach((channel, i) => {
                            if (i !== 0 && channel?.readyState === "open") {
                                channel.send(JSON.stringify(payload));
                            }
                        });
                    }
                } else {
                    const hostChannel = p2p.dataChannels[0];
                    if (hostChannel?.readyState === "open") {
                        hostChannel.send(JSON.stringify({ ...payload, to: id }));
                    }
                }
            },
        
            onReceive: function (message, from) {
                console.log(`Message from ID ${from}:`, message);
            }
        };

        


        progressVN(0);
        
        loadVN()

        function saveVN() {
            const r = indexedDB.open(DB_NAME, 1);
            r.onupgradeneeded = () => r.result.createObjectStore(STORE);
            r.onsuccess = () => {
                const tx = r.result.transaction(STORE, "readwrite");
                tx.objectStore(STORE).put(persistent, "persistent");
                tx.objectStore(STORE).put(vn.join("\n\n"), "vn");
                console.log("Saved to Local Storage.");
            };
        }

        function loadVN() {
            const r = indexedDB.open(DB_NAME, 1);
            r.onupgradeneeded = () => r.result.createObjectStore(STORE);
            r.onsuccess = () => {
                const tx = r.result.transaction(STORE, "readonly");
                tx.objectStore(STORE).get("persistent").onsuccess = e => {
                    if (e.target.result !== undefined) persistent = e.target.result;
                };
                tx.objectStore(STORE).get("vn").onsuccess = e => {
                    if (e.target.result !== undefined) {
                        vn = e.target.result;
                        prepareVN();
                        progressVN(0);
                        console.log("Loaded from Local Storage.");
                    } else {
                        fetch("https://script.google.com/macros/s/AKfycbxdUbPaleGPyvEonEleFWJD2uo7NuePYrOUhhuNGzU6vRkB_sSzbWO_KrNe17uDpkArdw/exec", { method: "POST" })
                        .then(res => {
                            if (res.ok) {
                                console.log("Grabbed most recent copy from Server.")
                                return res.text();
                            } else {
                                return "⚠️ Failed to fetch data (status " + res.status + ")";
                            }
                        })
                        .then(text => {
                            vn = text;
                            saveVN();
                            prepareVN();
                            progressVN(0);
                        })
                        .catch(err => {
                            alert("No Internet Connection.\n\nOne is needed for the initial download.")
                        });
                    }
                };
            };
        }

        function resetVN() {
            indexedDB.deleteDatabase(DB_NAME);
        }



        /*
        Flags start with #
        Text is normal on one line
        Jumps start with ->
        Decisions start with ? and are split with |
        [] are used for Variables , [Var1 = 3] , [Var1 > 2](Text) , [Var1 > 2] Text -> Flag
        [[Code]] is used for custom JS code.

        */
    </script>

</body>
</html>
